<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="http://www.springframework.org/schema/integration/file"
			xmlns:xsd="http://www.w3.org/2001/XMLSchema"
			xmlns:tool="http://www.springframework.org/schema/tool"
			xmlns:integration="http://www.springframework.org/schema/integration"
			targetNamespace="http://www.springframework.org/schema/integration/file"
			elementFormDefault="qualified">

	<xsd:import namespace="http://www.springframework.org/schema/beans"/>
	<xsd:import namespace="http://www.springframework.org/schema/integration"
				schemaLocation="https://www.springframework.org/schema/integration/spring-integration.xsd"/>

	<xsd:annotation>
		<xsd:documentation><![CDATA[
	Defines the configuration elements for Spring Integration File Adapters.
		]]></xsd:documentation>
	</xsd:annotation>

	<xsd:element name="inbound-channel-adapter">
		<xsd:annotation>
			<xsd:documentation>
				Configures a 'SourcePollingChannelAdapter' Endpoint for the
				'org.springframework.integration.file.FileReadingMessageSource' that
				polls a directory and sends Messages whose payloads are
				instances of java.io.File.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:choice minOccurs="0" maxOccurs="1">
					<xsd:sequence>
						<xsd:element ref="integration:poller"/>
						<xsd:choice minOccurs="0" maxOccurs="1">
							<xsd:element ref="locker"/>
							<xsd:element ref="nio-locker"/>
						</xsd:choice>
					</xsd:sequence>
					<xsd:sequence>
						<xsd:choice>
							<xsd:element ref="locker"/>
							<xsd:element ref="nio-locker"/>
						</xsd:choice>
						<xsd:element ref="integration:poller" minOccurs="0" maxOccurs="1"/>
					</xsd:sequence>
				</xsd:choice>
			</xsd:sequence>
			<xsd:attributeGroup ref="integration:channelAdapterAttributes"/>
			<xsd:attribute name="directory" type="xsd:string" use="required">
				<xsd:annotation>
					<xsd:documentation><![CDATA[Specifies the input directory (The directory to poll from) e.g.:
                    directory="file:/absolute/input" or directory="file:relative/input"]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="comparator" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
	Specify a Comparator to be used when ordering Files. If none is provided, the
	order will be determined by the java.io.File implementation of Comparable.  MUTUALLY EXCLUSIVE with queue-size.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="filter" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						Specify a FileListFilter to be used. By default, an AcceptOnceFileListFilter is used,
						which ensures files are picked up only once from the directory.

						You can also apply multiple filters by referencing a CompositeFileListFilter.
					]]></xsd:documentation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type type="org.springframework.integration.file.filters.FileListFilter"/>
						</tool:annotation>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="filter-expression" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						The SpEL expression to evaluate against file to accept it for processing or not.
						Mutually exclusive with 'filter' attribute.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="filename-pattern" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
Only files matching this ant style path will be picked up by this adapter. Note that
in Spring Integration 1.0 this attribute accepted a regular expression, but from 2.0
filename-regex should be used for that purpose instead.
                            ]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="filename-regex" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
Only files matching this regular expression will be picked up by this adapter.
                            ]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="scanner" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						Reference to a custom DirectoryScanner implementation.
						Mutually exclusive with 'use-watch-service' attribute.
					</xsd:documentation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type
									type="org.springframework.integration.file.DirectoryScanner"/>
						</tool:annotation>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="use-watch-service">
				<xsd:annotation>
					<xsd:documentation>
						Indicates if the 'FileReadingMessageSource' should use an internal 'DirectoryScanner'
						for the Java 7 'WatchService'.
						Mutually exclusive with 'scanner' attribute.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="watch-events" default="CREATE">
				<xsd:annotation>
					<xsd:documentation>
						Comma-separated value for the 'FileReadingMessageSource.WatchEventType's
						to specify which kinds of files system events the 'WatchService' will listen to.
						Used only if 'use-watch-service == true'.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="watchEventType xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="ignore-hidden">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
					A boolean flag indicating whether hidden files shall be ignored.
					If set to 'false', hidden files will be processed. If not specified,
					this value will default to 'true' and an 'IgnoreHiddenFileListFilter'
					will be added.
				]]></xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="prevent-duplicates" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
	A boolean flag indicating whether duplicates should be prevented. If a 'filter' reference is
	provided, duplicate prevention will not be enabled by default (the assumption is that the
	provided filter is sufficient), but setting this to true will enable it. If a 'filename-pattern'
	is provided, duplicate prevention will be enabled by default (preceding the pattern matching),
	but setting this to false will disable it. If neither 'filter' or 'filename-pattern' is provided,
	duplicate prevention is enabled by default, but setting this to false will disable it. For more
	detail on the actual duplicate prevention, see the javadoc for AcceptOnceFileListFilter.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="auto-create-directory" type="xsd:string" default="true">
				<xsd:annotation>
					<xsd:documentation>
						Specify whether to automatically create the source directory if it does not yet exist when this
						adapter is being initialized. The default value is 'true'. If set to 'false' and the directory
						does not exist upon initialization, an Exception will be thrown.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="queue-size" type="xsd:integer">
				<xsd:annotation>
					<xsd:documentation>
						Specify the maximum number of files stored in memory by the underlying FileReadingMessageSource.
						This is useful to limit the memory footprint of this endpoint. Using a stateful filter would
						counter
						this benefit, so AcceptOnceFileListFilter is not used when this attribute is specified.
						MUTUALLY EXCLUSIVE with comparator, if comparator is set this attribute will be ignored.
						MUTUALLY EXCLUSIVE with stateful filtering.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="scan-each-poll" default="false">
				<xsd:annotation>
					<xsd:documentation>
						Set this flag if you want to make sure the internal queue is
						refreshed with the latest content of the input directory on each poll.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>

	<xsd:simpleType name="watchEventType">
		<xsd:restriction base="xsd:token">
			<xsd:enumeration value="CREATE"/>
			<xsd:enumeration value="MODIFY"/>
			<xsd:enumeration value="DELETE"/>
		</xsd:restriction>
	</xsd:simpleType>


	<xsd:element name="outbound-channel-adapter">
		<xsd:annotation>
			<xsd:documentation>
				Configures a Consumer Endpoint for the
				'org.springframework.integration.file.FileWritingMessageHandler'
				with 'expectReply = false'
				that writes Message payloads to a File.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:extension base="outboundFileBaseType">
					<xsd:attribute name="channel" type="xsd:string">
						<xsd:annotation>
							<xsd:documentation>The channel through which outgoing messages will arrive.
							</xsd:documentation>
							<xsd:appinfo>
								<tool:annotation kind="ref">
									<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
								</tool:annotation>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:attribute>
				</xsd:extension>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>

	<xsd:element name="tail-inbound-channel-adapter">
		<xsd:annotation>
			<xsd:documentation>
				Configures a Message Producing Endpoint for the
				'org.springframework.integration.file.tail.FileTailingMessageProducerSupport that 'tails' a file on the
				filesystem.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attributeGroup ref="integration:channelAdapterAttributes"/>
			<xsd:attribute name="native-options" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						Configures the adapter to exec 'tail' with these options (appended by the file name).
						Default: "-F -n 0" (follow the filename and emit no
						existing lines). This attribute is not allowed if 'delay' 'end' or 'reopen' is
						specified, which cause the Apache commons-io 'Tailer' class to be used instead of
						using a native 'tail' command.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="enable-status-reader" default="true">
				<xsd:annotation>
					<xsd:documentation>
						Configure the adapter to either start a thread for capturing stderr or not.
						Default: True
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="file" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						The fully qualified name of the file to be tailed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="task-executor" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						A reference to a TaskExecutor; the default is a SimpleAsyncTaskExecutor; the
						native adapter uses three threads - one for reading stdout, one for
						reading stderr and one for monitoring the process.
					</xsd:documentation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type type="org.springframework.core.task.TaskExecutor"/>
						</tool:annotation>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="task-scheduler" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						A reference to a TaskScheduler; the default is the 'taskScheduler' bean
						which is automatically configured for all Spring Integration applications.
						The scheduler is used by the native adapter to reschedule
						the 'tail' process after a failure according to the 'file-delay', and also
						it is used to emit idle event.
					</xsd:documentation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type type="org.springframework.core.task.TaskExecutor"/>
						</tool:annotation>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="file-delay" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						The delay in milliseconds between attempts to open the file when no file was found (Apache
						adapter).
						For the native adapter, this is used as a delay before starting a new process after process
						failures.
						On some platforms, when the file doesn't exist, the 'tail' process is suspended until the file
						appears; on other platforms, the 'tail' process exits immediately if the file doesn't exist.
						Default 5000.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="delay" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						Does not apply to the native adapter - the delay in milliseconds between polls when no new
						data was detected in the file. Default 1000. Note: Setting this option forces the use of the
						Apache
						Tailer implementation instead of the native 'tail' command.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="idle-event-interval" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						The delay in milliseconds between idle events when no new lines are being tailed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="end">
				<xsd:annotation>
					<xsd:documentation>
						Does not apply to the native adapter.
						Set to 'true' to tail from the end of the file, 'false' to tail from the beginning of the file.
						Default 'true'. Note: Setting this option forces the use of the Apache
						Tailer implementation instead of the native 'tail' command.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="reopen">
				<xsd:annotation>
					<xsd:documentation>
						Does not apply to the native adapter.
						If 'true', close and reopen the file between reading chunks.
						Default 'false'. Note: Setting this option forces the use of the Apache
						Tailer implementation instead of the native 'tail' command.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="error-channel" use="optional" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						Message Channel to which error Messages should be sent.
					</xsd:documentation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
						</tool:annotation>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>

	<xsd:element name="outbound-gateway">
		<xsd:annotation>
			<xsd:documentation>
				Configures a Consumer Endpoint for the
				'org.springframework.integration.file.FileWritingMessageHandler'
				that writes request Message payloads to a File and then generates a
				reply Message containing the newly written File as its payload.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:extension base="outboundFileBaseType">
					<xsd:attribute name="request-channel" type="xsd:string">
						<xsd:annotation>
							<xsd:documentation>The channel through which outgoing messages will arrive.
							</xsd:documentation>
							<xsd:appinfo>
								<tool:annotation kind="ref">
									<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
								</tool:annotation>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:attribute>
					<xsd:attribute name="reply-channel" type="xsd:string">
						<xsd:annotation>
							<xsd:documentation>
								<![CDATA[After writing the File, it will be sent to the specified reply channel as the payload of a Message.
                                         Another way of providing the 'reply-channel' is by setting the MessageHeaders.REPLY_CHANNEL Message Header]]>
							</xsd:documentation>
							<xsd:appinfo>
								<tool:annotation kind="ref">
									<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
								</tool:annotation>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:attribute>
					<xsd:attribute name="reply-timeout" type="xsd:string" default="30000">
						<xsd:annotation>
							<xsd:documentation><![CDATA[
								Allows you to specify how long this gateway will wait for
								the reply message to be sent successfully to the reply channel
								before throwing an exception. This attribute only applies when the
								channel might block, for example when using a bounded queue channel that
								is currently full.

								Also, keep in mind that when sending to a DirectChannel, the
								invocation will occur in the sender's thread. Therefore,
								the failing of the send operation may be caused by other
								components further downstream.

								The "reply-timeout" attribute maps to the "sendTimeout" property of the
								underlying 'MessagingTemplate' instance (org.springframework.integration.core.MessagingTemplate).

								The value is specified in milliseconds.
							]]></xsd:documentation>
						</xsd:annotation>
					</xsd:attribute>
					<xsd:attribute name="requires-reply" type="xsd:string" use="optional" default="true">
						<xsd:annotation>
							<xsd:documentation>
								Specify whether this outbound gateway must return a non-null value. This value is
								'true' by default, and a ReplyRequiredException will be thrown when
								the underlying service returns a null value.
							</xsd:documentation>
						</xsd:annotation>
					</xsd:attribute>
				</xsd:extension>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>

	<xsd:complexType name="outboundFileBaseType">
		<xsd:choice minOccurs="0" maxOccurs="2">
			<xsd:element ref="integration:poller" minOccurs="0" maxOccurs="1"/>
			<xsd:element name="transactional" type="integration:transactionalType" minOccurs="0" maxOccurs="1"/>
			<xsd:element name="request-handler-advice-chain" type="integration:handlerAdviceChainType" minOccurs="0"
						 maxOccurs="1"/>
		</xsd:choice>
		<xsd:attribute name="id" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[Identifies the underlying Spring bean definition (EventDrivenConsumer)]]></xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="directory" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[Specifies the output directory, e.g.:
					directory="file:/absolute/output" or directory="file:relative/output"
					Either this attribute or 'directory-expression' must be provided.
				]]></xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="directory-expression" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[Specifies the output directory using a SpEL expression.
					This allows you to dynamically specify the output directory
					on a per message basis. For example a message header or payload
					property can be used for specifying the destination directory
					at runtime.]]>
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="filename-generator" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[Allows you to provide a reference to the FileNameGenerator strategy
                    to use when generating the destination file's name. If not specified the
                    DefaultFileNameGenerator is used.]]>
				</xsd:documentation>
				<xsd:appinfo>
					<tool:annotation kind="ref">
						<tool:expected-type type="org.springframework.integration.file.FileNameGenerator"/>
					</tool:annotation>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="filename-generator-expression" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Allows you to provide a SpEL expression which will compute the file name of
					the target file (e.g., assuming payload is java.io.File "payload.name + '.transferred'");
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="temporary-file-suffix" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Extension used when uploading files. We change it after we know it's uploaded.
					This attribute is mutually exclusive with 'append' since the append is done to the
					actual file and not its temporary counterpart. The default value of this attribute (i.e., .writing)
					is ignored when 'append' is set to true.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attributeGroup ref="modeGroup"/>
		<xsd:attribute name="delete-source-files" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation><![CDATA[
	Specify whether to delete source files after writing to the destination directory.
	This will take effect if the Message payload is the actual source File instance
	or if the original File instance (or its path) is available in the header value
	associated with the FileHeaders.ORIGINAL_FILE constant. The default value is false.
				]]></xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="order" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation><![CDATA[
	Specifies the order for invocation when this endpoint is connected as a
	subscriber to a SubscribableChannel.
				]]></xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="auto-create-directory" type="xsd:string" default="true">
			<xsd:annotation>
				<xsd:documentation>
					Specify whether to automatically create the destination directory if it does not yet exist when this
					adapter is being initialized. The default value is 'true'. If set to 'false' and the directory does
					not exist upon initialization, an Exception will be thrown.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="charset" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Set the charset name to use when writing a File from a String-based
					Message payload, e.g. charset="UTF-8". If not set, the default charset of this
					Java virtual machine is used.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="append-new-line" type="xsd:string" default="false">
			<xsd:annotation>
				<xsd:documentation>
					Set to 'true' to append a new-line after each write.
					It is 'false' by default.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="buffer-size" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					The buffer size to use when writing to files.
					Default 8192 bytes.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="flush-interval" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					When using 'mode=APPEND_NO_FLUSH', if this time (ms) elapses
					without any new writes, the data is flushed and the file closed.
					Default 30000.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="flush-when-idle" default="true">
			<xsd:annotation>
				<xsd:documentation>
					When using 'mode=APPEND_NO_FLUSH', set to false to indicate the
					'flush-interval' starts from the first new write to a previously
					flushed (or new) file. When true, the interval starts from the
					last write (the file is flushed if it has no writes during the interval).
					Default true.
				</xsd:documentation>
			</xsd:annotation>
			<xsd:simpleType>
				<xsd:union memberTypes="xsd:boolean xsd:string"/>
			</xsd:simpleType>
		</xsd:attribute>
		<xsd:attribute name="flush-predicate" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					When using 'mode=APPEND_NO_FLUSH',
					a reference to a 'FlushPredicate' implementation used when a message is
					sent to the message handler's 'MessageTriggerAction.trigger()' method.
					By default, the payload of such a message must be a Regex used to match
					the file absolute path.
				</xsd:documentation>
				<xsd:appinfo>
					<tool:annotation kind="ref">
						<tool:expected-type
								type="org.springframework.integration.file.FileWritingMessageHandler.MessageFlushPredicate"/>
					</tool:annotation>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="preserve-timestamp" type="xsd:string" default="false">
			<xsd:annotation>
				<xsd:documentation>
					Specify whether to preserve the modified timestamp from the source
					file on the destination file after copying. Applies to 'java.io.File' payloads.
					For other payload types, the optional 'file_setModified' header will be used,
					if present (and a 'Number'), to set the lastModified time.
					By default, the timestamp will NOT be preserved.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attributeGroup ref="chmod"/>
		<xsd:attributeGroup ref="integration:smartLifeCycleAttributeGroup"/>
	</xsd:complexType>

	<xsd:element name="file-to-string-transformer">
		<xsd:annotation>
			<xsd:documentation>
				Creates a 'org.springframework.integration.file.transformer.FileToStringTransformer'
				that converts a File payload to a String.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:extension base="transformerType">
					<xsd:attribute name="charset" type="xsd:string">
						<xsd:annotation>
							<xsd:documentation>
								<![CDATA[Set the charset name to use when converting a File
						        payload to a String, e.g. charset="UTF-8". If not set, the default charset of this
						        Java virtual machine is used.]]>
							</xsd:documentation>
						</xsd:annotation>
					</xsd:attribute>
				</xsd:extension>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>

	<xsd:element name="file-to-bytes-transformer">
		<xsd:annotation>
			<xsd:documentation>
				Creates a 'org.springframework.integration.file.transformer.FileToByteArrayTransformer'
				that converts a File payload to an array of bytes.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:complexContent>
				<xsd:extension base="transformerType"/>
			</xsd:complexContent>
		</xsd:complexType>
	</xsd:element>

	<xsd:complexType name="transformerType">
		<xsd:choice minOccurs="0" maxOccurs="2">
			<xsd:element ref="integration:poller" minOccurs="0" maxOccurs="1"/>
			<xsd:element name="request-handler-advice-chain" type="integration:handlerAdviceChainType"
						 minOccurs="0" maxOccurs="1"/>
		</xsd:choice>
		<xsd:attribute name="id" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Identifies the underlying Spring bean definition (EventDrivenConsumer)
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="input-channel" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[The input channel of the transformer.]]>
				</xsd:documentation>
				<xsd:appinfo>
					<tool:annotation kind="ref">
						<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
					</tool:annotation>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="output-channel" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[The channel to which the transformer will send the transformed message.
                    Optional, because incoming messages can specify a reply channel using the 'replyChannel'
                    message header value themselves.]]>
				</xsd:documentation>
				<xsd:appinfo>
					<tool:annotation kind="ref">
						<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
					</tool:annotation>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="delete-files" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					<![CDATA[The delete-files option signals to the transformer that it should delete the
                    inbound File after the transformation is complete.]]>
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:element name="splitter">
		<xsd:annotation>
			<xsd:documentation>
				Creates a 'org.springframework.integration.file.splitter.FileSplitter'
				that splits text-based files into lines.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice minOccurs="0" maxOccurs="2">
				<xsd:element name="poller" type="integration:basePollerType" minOccurs="0" maxOccurs="1"/>
				<xsd:element name="transactional" type="integration:transactionalType" minOccurs="0" maxOccurs="1"/>
				<xsd:element name="request-handler-advice-chain" type="integration:handlerAdviceChainType" minOccurs="0"
							 maxOccurs="1"/>
			</xsd:choice>
			<xsd:attributeGroup ref="integration:inputOutputChannelGroup"/>
			<xsd:attribute name="id" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						<![CDATA[Identifies the underlying Spring bean definition (EventDrivenConsumer)]]></xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="charset" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						<![CDATA[Set the charset name to use when reading bytes from the text-based file into String
						payloads, e.g. charset="UTF-8". If not set, the default charset of this
						Java virtual machine is used.
						]]>
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="first-line-as-header" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						The header name for the first line to be carried as a header in the messages emitted for the
						remaining lines.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name="requires-reply" use="optional" default="false">
				<xsd:annotation>
					<xsd:documentation>
						Specify whether the splitter must return at least one message. This value will be
						'false' by default, but if set to 'true', a ReplyRequiredException will be thrown when
						the file has no data.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="apply-sequence" use="optional">
				<xsd:annotation>
					<xsd:documentation>
						Set this flag to determine whether sequence related headers are added to messages
						from this splitter. When true, existing correlation and sequence related headers
						are pushed onto a stack; downstream components, such as aggregators may pop
						the stack to revert the existing headers after aggregation. Default is 'true'
						unless 'markers' is 'true'. Also see 'iterator'.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="iterator" use="optional" default="true">
				<xsd:annotation>
					<xsd:documentation>
						Set this flag to determine whether the lines are emitted via an iterator (line at a time)
						or the whole file is read into memory and then the lines emitted. When this is 'true', if
						'apply-sequence' is also 'true', the 'sequenceSize' header is set to '0'. Default: 'true'.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="markers" use="optional" default="false">
				<xsd:annotation>
					<xsd:documentation>
						Set to 'true' to emit start/end of file marker messages before and after the file data.
						Markers are messages with 'FileSplitter.FileMarker' payloads (with 'START' and 'END' values
						in the 'mark' property).
						Markers might be used when sequentially processing files in a downstream flow where some lines
						are filtered.
						The 'END' marker includes a line count.
						They enable the downstream processing to know when a file has been completely processed.
						A header 'file_marker' is also added, containing START/END appropriately.
						Default: 'false'.
						When 'true', 'apply-sequence' is 'false' by default.
						Also see 'markers-json'.
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="markers-json" use="optional" default="false">
				<xsd:annotation>
					<xsd:documentation>
						When 'markers' is true, if this is 'true', the message payload of the marker
						is a JSON String representation of the marker object.
						Requires a supported JSON processor library on the classpath (Jackson, Boon).
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:union memberTypes="xsd:boolean xsd:string"/>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name="discard-channel" type="xsd:string">
				<xsd:annotation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type type="org.springframework.messaging.MessageChannel"/>
						</tool:annotation>
					</xsd:appinfo>
					<xsd:documentation>
						The channel where the splitter will send the messages that return an empty container from
						split function.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>

	<xsd:element name="locker">
		<xsd:annotation>
			<xsd:documentation>
				<![CDATA[When multiple processes are reading from the same
				directory it can be desirable to lock files to prevent them
				from being picked up concurrently. To do this you can specify a reference to a FileLocker.]]>
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name="ref" type="xsd:string">
				<xsd:annotation>
					<xsd:documentation>
						<![CDATA[The reference to the FileLocker.]]>
					</xsd:documentation>
					<xsd:appinfo>
						<tool:annotation kind="ref">
							<tool:expected-type type="org.springframework.integration.file.FileLocker"/>
						</tool:annotation>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>

	<xsd:element name="nio-locker">
		<xsd:annotation>
			<xsd:documentation>
				<![CDATA[When multiple processes are reading from the same directory
           it can be desirable to lock files to prevent them from being picked up
           concurrently. This is a java.nio based implementation available out of the box.]]>
			</xsd:documentation>
		</xsd:annotation>
	</xsd:element>

	<xsd:simpleType name="mode">
		<xsd:restriction base="xsd:token">
			<xsd:enumeration value="REPLACE">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						This is the default behavior when writing files. If the
						target file already exists, it will be overwritten.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="REPLACE_IF_MODIFIED">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						If the local file already exists, it will be overwritten only
						if the last modified timestamp does not match the source
						timestamp. Only applies to local files.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="APPEND">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						If append is specified, the data will be appended
						to the existing file if such file exists, otherwise the
						new file will be created as usual but, once created,
						subsequent data will be appended to it. This attribute
						is mutually exclusive with the use of a temporary file,
						since append is done to the actual file and not its
						temporary counterpart.

						If set to APPEND, the component will also use an
						instance of the LockRegistry to ensure that there are no
						collisions when multiple threads are writing to the same
						file.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="APPEND_NO_FLUSH">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						Same as 'APPEND' but the data is not flushed or the file
						closed. This can significantly improve performance at the
						risk of lost data in the event of a failure.

						Various strategies are available for flushing the data and
						closing the file. Refer to the reference documentation for
						more information.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="FAIL">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						If the target file exists, a MessageHandlingException
						is thrown.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="IGNORE">
				<xsd:annotation>
					<xsd:documentation><![CDATA[
						If the target file exists, the message payload is silently
						ignored.
					]]></xsd:documentation>
				</xsd:annotation>
			</xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="remoteGatewayCommand">
		<xsd:restriction base="xsd:token">
			<xsd:enumeration value="ls"/>
			<xsd:enumeration value="nlst"/>
			<xsd:enumeration value="get"/>
			<xsd:enumeration value="rm"/>
			<xsd:enumeration value="mget"/>
			<xsd:enumeration value="mv"/>
			<xsd:enumeration value="put"/>
			<xsd:enumeration value="mput"/>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:attributeGroup name="remoteOutboundAttributeGroup">
		<xsd:attribute name="charset" type="xsd:string" default="UTF-8">
			<xsd:annotation>
				<xsd:documentation>
					Allows you to specify Charset (e.g., US-ASCII, ISO-8859-1, UTF-8). [UTF-8] is default -
					used when converting String payloads to bytes.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="temporary-remote-directory-expression"
					   type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Specify a SpEL expression which
					will be used to evaluate the temporary directory
					path to where files will be transferred before they are moved to the remote-directory
					(e.g., "headers.['remote_dir'] +
					'/temp/myTransfers'");
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="auto-create-directory" type="xsd:string"
					   default="false">
			<xsd:annotation>
				<xsd:documentation>
					Specify whether to automatically create the
					remote target directory if
					it doesn't exist.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="remote-filename-generator" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Allows you to specify a reference to
					[org.springframework.integration.file.FileNameGenerator] bean.
				</xsd:documentation>
				<xsd:appinfo>
					<tool:annotation kind="ref">
						<tool:expected-type
								type="org.springframework.integration.file.FileNameGenerator"/>
					</tool:annotation>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="remote-filename-generator-expression"
					   type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Allows you to provide SpEL expression which
					will compute file name of
					the remote file (e.g., assuming payload
					is java.io.File
					"payload.getName() + '.transferred'");
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attribute name="use-temporary-file-name" type="xsd:string" default="true">
			<xsd:annotation>
				<xsd:documentation>
					Allows you to suppress using a temporary file name while writing the file.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
		<xsd:attributeGroup ref="modeGroup"/>
	</xsd:attributeGroup>

	<xsd:attributeGroup name="modeGroup">
		<xsd:attribute name="mode">
			<xsd:annotation>
				<xsd:documentation><![CDATA[
					This attribute defaults to 'REPLACE' if not set explicitly.

					The following options are available:

					APPEND:

					If append is specified, the data will be appended
					to the existing file if such file exists, otherwise the
					new file will be created as usual but, once created, the
					subsequent data will be appended to it. This attribute
					is mutually exclusive with the use of a temporary file,
					since append is done to the actual file and not its
					temporary counterpart. The file is closed after each write.

					If set to APPEND, the component will also use
					instance of the LockRegistry to ensure that there are no
					collisions when multiple threads are writing to the same
					file.

					APPEND_NO_FLUSH:

					Same as 'APPEND' but the data is not flushed or the file
					closed. This can significantly improve performance at the
					risk of lost data in the event of a failure.

					Various strategies are available for flushing the data and
					closing the file. Refer to the reference documentation for
					more information.

					FAIL:

					If the target file exists, a MessageHandlingException
					is thrown.

					IGNORE:

					If the target file exists, the message payload is silently
					ignored.

					REPLACE:

					This is the default behavior when writing files. If the
					target file already exists, it will be overwritten.

					REPLACE_IF_MODIFIED:

					If the local file already exists, it will be overwritten only
					if the last modified timestamp does not match the source
					timestamp. Only applies to local files.
				]]></xsd:documentation>
			</xsd:annotation>
			<xsd:simpleType>
				<xsd:union memberTypes="mode xsd:string"/>
			</xsd:simpleType>
		</xsd:attribute>
	</xsd:attributeGroup>

	<xsd:attributeGroup name="chmod">
		<xsd:attribute name="chmod" type="xsd:string">
			<xsd:annotation>
				<xsd:documentation>
					Change the mode of the file (or remote file) after writing. Integer value
					expressed in Octal, e.g. '644'.
				</xsd:documentation>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:attributeGroup>

</xsd:schema>
