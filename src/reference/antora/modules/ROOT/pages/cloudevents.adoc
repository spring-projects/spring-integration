[[cloudevents]]
= CloudEvents Support

Spring Integration provides support for the CloudEvents https://github.com/cloudevents/spec[specification].

Add the following dependency to your project:

[tabs]
======
Maven::
+
[source, xml, subs="normal", role="primary"]
----
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-cloudevents</artifactId>
    <version>{project-version}</version>
</dependency>
----

Gradle::
+
[source, groovy, subs="normal", role="secondary"]
----
implementation "org.springframework.integration:spring-integration-cloudevents:{project-version}"
----
======

[[to-cloud-event-transformer]]
== `ToCloudEventTransformer`

Use the `ToCloudEventTransformer` to convert Spring Integration messages into CloudEvents-compliant messages.
This transformer supports the CloudEvents specification v1.0 and serializes CloudEvents if an `EventFormat` or `eventFormatContentTypeExpression` is specified.
When you specify an `EventFormat` or `eventFormatContentTypeExpression`, the transformer uses the `EventFormat` to generate the CloudEvent in the payload.
If neither is specified, the transformer writes the event data message payload as-is and adds attributes as well as extensions to the message headers.
The transformer supports defining attributes using expressions and identifies extensions in the message headers via patterns.

=== Attribute Expressions

Set the CloudEvents' attributes of `id`, `source`, `type`, `dataSchema`, and `subject` through SpEL expressions.

NOTE: The transformer sets the `time` attribute to the time when it creates the CloudEvent instance.

The following table lists the attribute names and the values the default expressions return.

|===
| Attribute Name | Default Value

| `id`
| The id of the message.

| `source`
| A prefix of "/spring/" followed by the appName, a period, and then the name of the transformer's bean, e.g., `/spring/myapp.toCloudEventTransformerBean`.

| `type`
| "spring.message"

| `dataContentType`
| The contentType of the message, defaults to `application/octet-stream`.
Some other examples include, but are not limited to: `application/json`, `application/x-avro`, and `application/xml`.

| `dataSchema`
| The URI to the specified schema.
The default for `dataSchema` is `null`.

| `subject`
| This attribute identifies the subject of the event in the context of the event producer.
The default for `subject` is `null`.

| `time`
| The time the CloudEvent message is created.
Set internally to the current time.
Note that you cannot configure this value.
|===

=== Extension Patterns

Use the `extensionPatterns` constructor parameter (a vararg of strings) to specify pattern matching with wildcards (`*`).
The transformer includes message headers with keys matching any pattern as CloudEvent extensions.
Use a `!` prefix to explicitly exclude headers through negation.
Note that the first matching pattern wins (whether positive or negative).

For example, configure patterns `"trace*", "span-id", "user-id"` to:
- Include headers starting with `trace` (e.g., `trace-id`, `traceparent`)
- Include headers with exact keys `span-id` and `user-id`
- Add all matching headers as extensions to the CloudEvent

To exclude specific headers, use negated patterns: `"custom-*", "!custom-internal"` includes all headers starting with `custom-` except `custom-internal`.

[[configuration-with-dsl]]
=== Configuration with DSL

Add the CloudEvent transformer to flows using the DSL:

[source,java]
----
@Bean
public ToCloudEventTransformer cloudEventTransformer() {
    return new ToCloudEventTransformer("trace*", "correlation-id");
}

@Bean
public IntegrationFlow cloudEventTransformFlow(ToCloudEventTransformer toCloudEventTransformer) {
    return IntegrationFlows
        .from("inputChannel")
        .transform(toCloudEventTransformer)
        .channel("outputChannel")
        .get();
}
----

[[cloudevent-transformer-process]]
=== CloudEvent Transformer Process

Understand the transformation process:

1. **CloudEvent Building**: Build the CloudEvent attributes.
2. **Extension Extraction**: Build the CloudEvent extensions using the array of extensionPatterns passed into the constructor.
3. **Format Conversion**: Apply the specified `EventFormat` or, if not set, handle the conversion via Binary Format Mode.

A basic transformation may have the following pattern:

[source,java]
----
// Input message with headers
Message<byte[]> inputMessage = MessageBuilder
    .withPayload("Hello CloudEvents".getBytes(StandardCharsets.UTF_8))
    .withHeader(MessageHeaders.CONTENT_TYPE, "text/plain")
    .build();

ToCloudEventTransformer transformer = new ToCloudEventTransformer();

// Transform to CloudEvent
Object cloudEventMessage = transformer.transform(inputMessage);
----

[[eventformats]]
=== EventFormats

The ToCloudEventTransformer will use formatting to serialize the CloudEvent into the message's payload when the `EventFormat` is available, or use Binary Format Mode otherwise.
Set the `EventFormat` in one of two ways:

1. Set the desired `EventFormat`.
2. Set the `eventFormatContentTypeExpression` with an expression that resolves to a content type that `EventFormatProvider` can use to provide the required `EventFormat`.
When the `eventFormatContentTypeExpression` is set and the `EventFormatProvider` returns null because it cannot find the `EventFormat` for the content type, the transformer throws a `MessageTransformationException`.
Examples of content types that the `eventFormatContentTypeExpression` can resolve to that are accepted by the `EventFormatProvider` are:
   - `application/cloudevents+json`
   - `application/cloudevents+xml`

If the `EventFormat` and the `eventFormatContentTypeExpression` are not set, the transformer adds cloud event attributes and extensions to the message headers with the cloud event prefix (default is `ce-`) and leaves the payload unchanged (Binary Format Mode).

To utilize a specific `EventFormat`, add the associated dependency.
For example, to add the XML `EventFormat`, add the following dependency: `io.cloudevents:cloudevents-xml`.
See the https://cloudevents.github.io/sdk-java[CloudEvents Java Reference Documentation] for information on the event formats that are available.

NOTE: Ensure messages to be transformed to CloudEvents have a payload of type `byte[]`.
The transformer throws an `IllegalArgumentException` if the payload is not a byte array.

[[from-cloud-event-transformer]]
== `FromCloudEventTransformer`

Use the `FromCloudEventTransformer` to convert CloudEvents into Spring Integration messages.
This transformer supports the CloudEvents specification v1.0 and processes CloudEvents from two payload types: CloudEvent objects or serialized CloudEvent byte arrays.

The transformer extracts CloudEvent data from the message payload and maps CloudEvent attributes to message headers.
All CloudEvent extensions are automatically mapped to message headers with the `ce-` prefix.

=== Supported Payload Types

The transformer accepts messages with the following payload types:

==== CloudEvent Object Type

When the message payload is a `CloudEvent` instance, the transformer:

1. Extracts the CloudEvent data and uses it as the message payload
2. Maps CloudEvent attributes (`id`, `source`, `type`, `time`, `subject`, `datacontenttype`, `dataschema`) to message headers using the keys enumerated in the <<cloudevent-attribute-mapping>> section.
3. Maps all CloudEvent extensions to message headers with the `ce-` prefix
4. Preserves all original message headers

Example:

[source,java]
----
String orderJson = ...

CloudEvent cloudEvent = CloudEventBuilder.v1()
    .withId("event-123")
    .withSource(URI.create("/myapp/orders"))
    .withType("order.created")
    .withData("application/json", orderJson.getBytes())
    .withExtension("traceid", "trace-abc")
    .build();

Message<CloudEvent> inputMessage = MessageBuilder
    .withPayload(cloudEvent)
    .build();

FromCloudEventTransformer transformer = new FromCloudEventTransformer();
Message<?> outputMessage = transformer.transform(inputMessage);
----

==== Serialized CloudEvent Type

When the message payload is a `byte[]` containing a serialized CloudEvent, the transformer:

1. Uses the `content-type` header to resolve the appropriate `EventFormat` via `EventFormatProvider`
2. Deserializes the payload to a `CloudEvent` object using the resolved format
3. Extracts the CloudEvent data and uses it as the message payload
4. Maps CloudEvent attributes to message headers using the message header keys enumerated in the <<cloudevent-attribute-mapping>> section.
5. Maps all CloudEvent extensions to message headers with the `ce-` prefix

Supported content types include:

- `application/cloudevents+json` (requires `io.cloudevents:cloudevents-json-jackson` dependency)
- `application/cloudevents+xml` (requires `io.cloudevents:cloudevents-xml` dependency)

Example:

[source,java]
----
byte[] serializedCloudEvent = ... // JSON serialized CloudEvent

Message<byte[]> inputMessage = MessageBuilder
    .withPayload(serializedCloudEvent)
    .setHeader(MessageHeaders.CONTENT_TYPE, "application/cloudevents+json")
    .build();

FromCloudEventTransformer transformer = new FromCloudEventTransformer();
Message<?> outputMessage = transformer.transform(inputMessage);

----

[#cloudevent-attribute-mapping]
=== CloudEvent Attribute Mapping

The transformer maps CloudEvent attributes to message headers using the following `CloudEventHeaders` constants:

|===
| CloudEvent Attribute | Message Header Key | Required

| `id`
| `ce-id`
| Yes

| `source`
| `ce-source`
| Yes

| `type`
| `ce-type`
| Yes

| `time`
| `ce-time`
| No

| `subject`
| `ce-subject`
| No

| `datacontenttype`
| `ce-datacontenttype`
| No

| `dataschema`
| `ce-dataschema`
| No

| extensions
| `ce-{extensionName}`
| No
|===

NOTE: The `content-type` header in the output message is always set to the CloudEvent's `datacontenttype` value.

=== Configuration with DSL

Add the CloudEvent transformer to flows using the DSL:

[source,java]
----
@Bean
public FromCloudEventTransformer fromCloudEventTransformer() {
    return new FromCloudEventTransformer();
}

@Bean
public IntegrationFlow fromCloudEventFlow(FromCloudEventTransformer fromCloudEventTransformer) {
    return IntegrationFlows
        .from("cloudEventInputChannel")
        .transform(fromCloudEventTransformer)
        .channel("messageOutputChannel")
        .get();
}
----

=== Requirements and Constraints

The transformer has the following requirements:

- **Payload Type**: Must be either a `CloudEvent` instance or `byte[]`
- **Content-Type Header**: Required when the payload is of type `byte[]` (used to resolve the `EventFormat`)
- **CloudEvent Data**: CloudEvent instances and CloudEvents serialized as byte[] must contain non-null data (empty byte arrays are acceptable)

