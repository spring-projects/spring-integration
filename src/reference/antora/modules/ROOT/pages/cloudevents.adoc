[[cloudevents]]
= CloudEvents Support

Spring Integration provides support for the CloudEvents https://github.com/cloudevents/spec[specification].

Add the following dependency to your project:

[tabs]
======
Maven::
+
[source, xml, subs="normal", role="primary"]
----
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-cloudevents</artifactId>
    <version>{project-version}</version>
</dependency>
----

Gradle::
+
[source, groovy, subs="normal", role="secondary"]
----
implementation "org.springframework.integration:spring-integration-cloudevents:{project-version}"
----
======

[[to-cloud-event-transformer]]
== `ToCloudEventTransformer`

Use the `ToCloudEventTransformer` to convert Spring Integration messages into CloudEvents-compliant messages.
This transformer supports the CloudEvents specification v1.0 and serializes CloudEvents if an `EventFormat` or `eventFormatContentTypeExpression` is specified.
When you specify an `EventFormat` or `eventFormatContentTypeExpression`, the transformer uses the `EventFormat` to generate the CloudEvent in the payload.
If neither is specified, the transformer writes the event data message payload as-is and adds attributes as well as extensions to the message headers.
The transformer supports defining attributes using expressions and identifies extensions in the message headers via patterns.

=== Attribute Expressions

Set the CloudEvents' attributes of `id`, `source`, `type`, `dataSchema`, and `subject` through SpEL expressions.

NOTE: The transformer sets the `time` attribute to the time when it creates the CloudEvent instance.

The following table lists the attribute names and the values the default expressions return.

|===
| Attribute Name | Default Value

| `id`
| The id of the message.

| `source`
| A prefix of "/spring/" followed by the appName, a period, and then the name of the transformer's bean, e.g., `/spring/myapp.toCloudEventTransformerBean`.

| `type`
| "spring.message"

| `dataContentType`
| The contentType of the message, defaults to `application/octet-stream`.
Some other examples include, but are not limited to: `application/json`, `application/x-avro`, and `application/xml`.

| `dataSchema`
| The URI to the specified schema.
The default for `dataSchema` is `null`.

| `subject`
| This attribute identifies the subject of the event in the context of the event producer.
The default for `subject` is `null`.

| `time`
| The time the CloudEvent message is created.
Set internally to the current time.
Note that you cannot configure this value.
|===

=== Extension Patterns

Use the `extensionPatterns` constructor parameter (a vararg of strings) to specify pattern matching with wildcards (`*`).
The transformer includes message headers with keys matching any pattern as CloudEvent extensions.
Use a `!` prefix to explicitly exclude headers through negation.
Note that the first matching pattern wins (whether positive or negative).

For example, configure patterns `"trace*", "span-id", "user-id"` to:
- Include headers starting with `trace` (e.g., `trace-id`, `traceparent`)
- Include headers with exact keys `span-id` and `user-id`
- Add all matching headers as extensions to the CloudEvent

To exclude specific headers, use negated patterns: `"custom-*", "!custom-internal"` includes all headers starting with `custom-` except `custom-internal`.

[[configuration-with-dsl]]
=== Configuration with DSL

Add the CloudEvent transformer to flows using the DSL:

[source,java]
----
@Bean
public ToCloudEventTransformer cloudEventTransformer() {
    return new ToCloudEventTransformer("trace*", "correlation-id");
}

@Bean
public IntegrationFlow cloudEventTransformFlow(ToCloudEventTransformer toCloudEventTransformer) {
    return IntegrationFlows
        .from("inputChannel")
        .transform(toCloudEventTransformer)
        .channel("outputChannel")
        .get();
}
----

[[cloudevent-transformer-process]]
=== CloudEvent Transformer Process

Understand the transformation process:

1. **CloudEvent Building**: Build the CloudEvent attributes.
2. **Extension Extraction**: Build the CloudEvent extensions using the array of extensionPatterns passed into the constructor.
3. **Format Conversion**: Apply the specified `EventFormat` or, if not set, handle the conversion via Binary Format Mode.

A basic transformation may have the following pattern:

[source,java]
----
// Input message with headers
Message<byte[]> inputMessage = MessageBuilder
    .withPayload("Hello CloudEvents".getBytes(StandardCharsets.UTF_8))
    .withHeader(MessageHeaders.CONTENT_TYPE, "text/plain")
    .build();

ToCloudEventTransformer transformer = new ToCloudEventTransformer();

// Transform to CloudEvent
Object cloudEventMessage = transformer.transform(inputMessage);
----

[[eventformats]]
=== EventFormats

The ToCloudEventTransformer will use formatting to serialize the CloudEvent into the message's payload when the `EventFormat` is available, or use Binary Format Mode otherwise.
Set the `EventFormat` in one of two ways:

1. Set the desired `EventFormat`.
2. Set the `eventFormatContentTypeExpression` with an expression that resolves to a content type that `EventFormatProvider` can use to provide the required `EventFormat`.
When the `eventFormatContentTypeExpression` is set and the `EventFormatProvider` returns null because it cannot find the `EventFormat` for the content type, the transformer throws a `MessageTransformationException`.
Examples of content types that the `eventFormatContentTypeExpression` can resolve to that are accepted by the `EventFormatProvider` are:
   - `application/cloudevents+json`
   - `application/cloudevents+xml`

If the `EventFormat` and the `eventFormatContentTypeExpression` are not set, the transformer adds cloud event attributes and extensions to the message headers with the cloud event prefix (default is `ce-`) and leaves the payload unchanged (Binary Format Mode).

To utilize a specific `EventFormat`, add the associated dependency.
For example, to add the XML `EventFormat`, add the following dependency: `io.cloudevents:cloudevents-xml`.
See the https://cloudevents.github.io/sdk-java[CloudEvents Java Reference Documentation] for information on the event formats that are available.

NOTE: Ensure messages to be transformed to CloudEvents have a payload of type `byte[]`.
The transformer throws an `IllegalArgumentException` if the payload is not a byte array.

[[from-cloud-event-transformer]]
== `FromCloudEventTransformer`

Use the `FromCloudEventTransformer` to convert CloudEvents-compliant messages into Spring Integration messages.
This transformer supports the CloudEvents specification v1.0 and deserializes CloudEvents from both serialized formats (structured content mode) and header-based representations (binary content mode).
When the transformer detects a serialized CloudEvent format (such as`application/cloudevents+json`) via the `content-type` header, it deserializes the payload using the appropriate `EventFormat`. CloudEvent attributes and extensions are extracted from the deserialized CloudEvent object and mapped to the output message headers. The  CloudEvent data becomes the payload for the new message.
If the `EventFormat` can't be resolved, the transformer extracts CloudEvent attributes and extensions from the headers and maps them to message headers using configurable keys.  The payload of the original message is used in the new message.

=== Deserialization Modes

The transformer operates in two modes based on the incoming message:

==== Serialized CloudEvent Mode

When the message `content-type` header can be resolved to a supported CloudEvent type, the transformer:

1. Deserializes the payload
2. Extracts CloudEvent attributes from the deserialized CloudEvent object
3. Maps attributes to output message headers using configured message header keys
4. Extracts the CloudEvent data as the message payload
5. Preserves CloudEvent extensions as message headers with the configured prefix (default: `ce-`)

==== Header-based CloudEvent Mode

When the `content-type` header can't be resolved to a supported CloudEvent, the transformer:

1. Reads CloudEvent attributes from message headers using configured CloudEvent header keys
2. Uses the message payload as CloudEvent data
3. Maps CloudEvent attributes to output message headers
4. Preserves CloudEvent extensions with the configured prefix

=== Header Key Configuration

The transformer provides separate configuration for input and output header keys:

**CloudEvent Header Keys** (`ceHeader*Key` setters): Used when reading CloudEvent attributes from incoming message headers in header-based mode.
These keys determine where the transformer looks for CloudEvent attributes in the input message.

**Message Header Keys** (`messageHeader*Key` setters): Used when writing CloudEvent attributes to the output message headers.
These keys determine the message header key names where CloudEvent attributes will be set in the transformed message.

By default, both sets of keys are initialized to the same CloudEvents standard header names (e.g., `ce-id`, `ce-source`, `ce-type`).
Configure different keys when integrating with systems using custom header naming conventions.

The following table lists the configurable header keys and their default values:

|===
| Attribute | Default CloudEvent Header Key | Default Message Header Key

| `id`
| `ce-id`
| `ce-id`

| `source`
| `ce-source`
| `ce-source`

| `type`
| `ce-type`
| `ce-type`

| `time`
| `ce-time`
| `ce-time`

| `datacontenttype`
| `ce-datacontenttype`
| `ce-datacontenttype`

| `subject`
| `ce-subject`
| `ce-subject`

| `dataschema`
| `ce-dataschema`
| `ce-dataschema`

| extensions
| `ce-*`
| `ce-*`
|===

=== Configuration with DSL

Add the CloudEvent transformer to flows using the DSL:

[source,java]
----
@Bean
public FromCloudEventTransformer fromCloudEventTransformer() {
    return new FromCloudEventTransformer();
}

@Bean
public IntegrationFlow fromCloudEventFlow(FromCloudEventTransformer fromCloudEventTransformer) {
    return IntegrationFlows
        .from("cloudEventInputChannel")
        .transform(fromCloudEventTransformer)
        .channel("messageOutputChannel")
        .get();
}
----

You can also configure the transformer with extension patterns to extract specific headers as CloudEvent extensions when operating in header-based mode:

[source,java]
----
@Bean
public FromCloudEventTransformer fromCloudEventTransformer() {
    return new FromCloudEventTransformer("trace*", "correlation-id");
}
----

NOTE: The transformer requires messages to have a payload of type `byte[]`  and a non-empty `content-type` header.
The transformer throws an `IllegalStateException` if the payload is not a byte array.
