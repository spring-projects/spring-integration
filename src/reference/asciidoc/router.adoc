[[router]]
=== Routers

[[router-overview]]
==== Overview

Routers are a crucial element in many messaging architectures.
They consume Messages from a Message Channel and forward each consumed message to one or more different Message Channel depending on a set of conditions.

Spring Integration provides the following routers out-of-the-box:

* _<<router-implementations-payloadtyperouter,Payload Type Router>>_
* _<<router-implementations-headervaluerouter,Header Value Router>>_
* _<<router-implementations-recipientlistrouter,Recipient List Router>>_
* _<<xml-xpath-routing,XPath Router (Part of the XML Module)>>_
* _<<router-implementations-exception-router,Error Message Exception Type Router>>_
* _<<router-namespace,(Generic) Router>>_



Router implementations share many configuration parameters.
Yet, certain differences exist between routers.
Furthermore, the availability of configuration parameters depends on whether Routers are used inside or outside of a chain.
In order to provide a quick overview, all available attributes are listed in the 2 tables below.

.Routers Outside of a Chain

[cols="2,1,1,1,1,1,1", options="header"]
|===

| Attribute


| router


| header value router


| xpath router


| payload type router


| recipient list router


| exception type router


| apply-sequence


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| default-output-channel


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| resolution-required


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| ignore-send-failures


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| timeout


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| id


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| auto-startup


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| input-channel


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| order


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| method


a| image::images/tickmark.png[]
|
|
|
|
|


| ref


a| image::images/tickmark.png[]
|
|
|
|
|


| expression


a| image::images/tickmark.png[]
|
|
|
|
|


| header-name


|
a| image::images/tickmark.png[]
|
|
|
|


| evaluate-as-string


|
|
a| image::images/tickmark.png[]
|
|
|


| xpath-expression-ref


|
|
a| image::images/tickmark.png[]
|
|
|


| converter


|
|
a| image::images/tickmark.png[]
|
|
|


|===

.Routers Inside of a Chain
[cols="2,1,1,1,1,1,1", options="header"]
|===


| Attribute


| router


| header value router


| xpath router


| payload type router


| recipient list router


| exception type router


| apply-sequence


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| default-output-channel


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| resolution-required


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| ignore-send-failures


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| timeout


a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]
a| image::images/tickmark.png[]


| id


|
|
|
|
|
|


| auto-startup


|
|
|
|
|
|


| input-channel


|
|
|
|
|
|


| order


|
|
|
|
|
|


| method


a| image::images/tickmark.png[]
|
|
|
|
|


| ref


a| image::images/tickmark.png[]
|
|
|
|
|


| expression


a| image::images/tickmark.png[]
|
|
|
|
|


| header-name


|
a| image::images/tickmark.png[]
|
|
|
|


| evaluate-as-string


|
|
a| image::images/tickmark.png[]
|
|
|


| xpath-expression-ref


|
|
a| image::images/tickmark.png[]
|
|
|


| converter


|
|
a| image::images/tickmark.png[]
|
|
|


|===

[IMPORTANT]
=====
Router parameters have been more standardized across all router implementations with Spring Integration 2.1.
Consequently, there are a few minor changes that leave the possibility of breaking older Spring Integration based applications.

Since Spring Integration 2.1 the `ignore-channel-name-resolution-failures` attribute is removed in favor of consolidating its behavior with the `resolution-required` attribute.
Also, the `resolution-required` attribute now defaults to `true`.

Prior to these changes, the `resolution-required` attribute defaulted to `false` causing messages to be silently dropped when no channel was resolved and no `default-output-channel` was set.
The new behavior will require at least one resolved channel and by default will throw an `MessageDeliveryException` if no channel was determined (or an attempt to send was not successful).

If you do desire to drop messages silently simply set `default-output-channel="nullChannel"`.
=====
[[router-common-parameters]]
==== Common Router Parameters

[[router-common-parameters-all]]
===== Inside and Outside of a Chain

The following parameters are valid for all routers inside and outside of chains.

*apply-sequence*::


This attribute specifies whether sequence number and size headers should be added to each Message.
This _optional_ attribute defaults to _false_.




*default-output-channel*::


If set, this attribute provides a reference to the channel, where Messages should be sent, if channel resolution fails to return any channels.
If no default output channel is provided, the router will throw an Exception.
If you would like to silently drop those messages instead, add the `nullChannel` as the default output channel attribute value.

NOTE: A Message will only be sent to the `default-output-channel` if `resolution-required` is false and the channel is not resolved.




*resolution-required*::


If _true_ this attribute specifies that channel names must always be successfully resolved to channel instances that exist.
If set to _true_, a `MessagingException` will be raised, in case the channel cannot be resolved.
Setting this attribute to _false_, will cause any unresovable channels to be ignored.
This _optional_ attribute will, if not explicitly set, default to _true_.

NOTE: A Message will only be sent to the `default-output-channel`, if specified, when `resolution-required` is false and the channel is not resolved.




*ignore-send-failures*::


If set to _true_, failures to send to a message channel will be ignored.
If set to _false_, a `MessageDeliveryException` will be thrown instead, and if the router resolves more than one channel, any subsequent channels will not receive the message.

The exact behavior of this attribute depends on the type of the `Channel` messages are sent to.
For example, when using direct channels (single threaded), send-failures can be caused by exceptions thrown by components much further down-stream.
However, when sending messages to a simple queue channel (asynchronous) the likelihood of an exception to be thrown is rather remote.

NOTE: While most routers will route to a single channel, they are allowed to return more than one channel name.
The `recipient-list-router`, for instance, does exactly that.
If you set this attribute to _true_ on a router that only routes to a single channel, any caused exception is simply swallowed, which usually makes little sense to do.
In that case it would be better to catch the exception in an error flow at the flow entry point.
Therefore, setting the `ignore-send-failures` attribute to _true_ usually makes more sense when the router implementation returns more than one channel name, because the other channel(s) following the one that fails would still receive the Message.

This attribute defaults to _false_.




*timeout*::


The `timeout` attribute specifies the maximum amount of time in milliseconds to wait, when sending Messages to the target Message Channels.
By default the send operation will block indefinitely.



[[router-common-parameters-top]]
===== Top-Level (Outside of a Chain)

The following parameters are valid only across all top-level routers that are ourside of chains.

*id*::


Identifies the underlying Spring bean definition which in case of Routers is an instance of EventDrivenConsumer or PollingConsumer depending on whether the Router's _input-channel_ is a _SubscribableChannel_ or _PollableChannel_, respectively.
This is an _optional_ attribute.




*auto-startup*::


This `Lifecycle` attribute signaled if this component should be started during startup of the Application Context.
This _optional_ attribute defaults to _true_.




*input-channel*::


The receiving Message channel of this endpoint.




*order*::


This attribute defines the order for invocation when this endpoint is connected as a subscriber to a channel.
This is particularly relevant when that channel is using a _failover_ dispatching strategy.
It has no effect when this endpoint itself is a Polling Consumer for a channel with a queue.



[[router-implementations]]
==== Router Implementations

Since content-based routing often requires some domain-specific logic, most use-cases will require Spring Integration's options for delegating to POJOs using the XML namespace support and/or Annotations.
Both of these are discussed below, but first we present a couple implementations that are available out-of-the-box since they fulfill common requirements.

[[router-implementations-payloadtyperouter]]
===== PayloadTypeRouter

A `PayloadTypeRouter` will send Messages to the channel as defined by payload-type mappings.
[source,xml]
----
<bean id="payloadTypeRouter"
      class="org.springframework.integration.router.PayloadTypeRouter">
    <property name="channelMapping">
        <map>
            <entry key="java.lang.String" value-ref="stringChannel"/>
            <entry key="java.lang.Integer" value-ref="integerChannel"/>
        </map>
    </property>
</bean>
----

Configuration of the `PayloadTypeRouter` is also supported via the namespace provided by Spring Integration (see <<configuration-namespace>>), which essentially simplifies configuration by combining the `<router/>` configuration and its corresponding implementation defined using a `<bean/>` element into a single and more concise configuration element.
The example below demonstrates a `PayloadTypeRouter` configuration which is equivalent to the one above using the namespace support:

[source,xml]
----
<int:payload-type-router input-channel="routingChannel">
    <int:mapping type="java.lang.String" channel="stringChannel" />
    <int:mapping type="java.lang.Integer" channel="integerChannel" />
</int:payload-type-router>
----

The equivalent router, using Java configuration:

[source, java]
----
@ServiceActivator(inputChannel = "routingChannel")
@Bean
public PayloadTypeRouter router() {
    PayloadTypeRouter router = new PayloadTypeRouter();
    router.setChannelMapping(String.class.getName(), "stringChannel");
    router.setChannelMapping(Integer.class.getName(), "integerChannel");
    return router;
}
----

When using the Java DSL, there are two options; 1) define the router object as above...

[source, java]
----
@Bean
public IntegrationFlow routerFlow1() {
    return IntegrationFlows.from("routingChannel")
            .route(router())
            .get();
}

public PayloadTypeRouter router() {
    PayloadTypeRouter router = new PayloadTypeRouter();
    router.setChannelMapping(String.class.getName(), "stringChannel");
    router.setChannelMapping(Integer.class.getName(), "integerChannel");
    return router;
}
----

Note that the router can be, but doesn't have to be, a `@Bean` - the flow will register it if it is not.

2) define the routing function within the DSL flow itself...

[source, java]
----
@Bean
public IntegrationFlow routerFlow2() {
    return IntegrationFlows.from("routingChannel")
            .<Object, Class<?>>route(Object::getClass, m -> m
                    .channelMapping(String.class, "stringChannel")
                    .channelMapping(Integer.class, "integerChannel"))
            .get();
}
----

[[router-implementations-headervaluerouter]]
===== HeaderValueRouter

A `HeaderValueRouter` will send Messages to the channel based on the individual header value mappings.
When a `HeaderValueRouter` is created it is initialized with the _name_ of the header to be evaluated.
The _value_ of the header could be one of two things:

1.
Arbitrary value

2.
Channel name

If arbitrary then additional mappings for these header values to channel names is required, otherwise no additional configuration is needed.

Spring Integration provides a simple namespace-based XML configuration to configure a `HeaderValueRouter`.
The example below demonstrates two types of namespace-based configuration for the `HeaderValueRouter`.

_1.
Configuration where mapping of header values to channels is required_

[source,xml]
----
<int:header-value-router input-channel="routingChannel" header-name="testHeader">
    <int:mapping value="someHeaderValue" channel="channelA" />
    <int:mapping value="someOtherHeaderValue" channel="channelB" />
</int:header-value-router>
----

During the resolution process this router may encounter channel resolution failures, causing an exception.
If you want to suppress such exceptions and send unresolved messages to the default output channel (identified with the `default-output-channel` attribute) set `resolution-required` to `false`.

Normally, messages for which the header value is not explicitly mapped to a channel will be sent to the `default-output-channel`.
However, in cases where the header value is mapped to a channel name but the channel cannot be resolved, setting the `resolution-required` attribute to `false` will result in routing such messages to the `default-output-channel`.

IMPORTANT: With Spring Integration 2.1 the attribute was changed from `ignore-channel-name-resolution-failures` to `resolution-required`.
Attribute `resolution-required` will default to `true`.

The equivalent router, using Java configuration:

[source, java]
----
@ServiceActivator(inputChannel = "routingChannel")
@Bean
public HeaderValueRouter router() {
    HeaderValueRouter router = new HeaderValueRouter("testHeader");
    router.setChannelMapping("someHeaderValue", "channelA");
    router.setChannelMapping("someOtherHeaderValue", "channelB");
    return router;
}
----

When using the Java DSL, there are two options; 1) define the router object as above...

[source, java]
----
@Bean
public IntegrationFlow routerFlow1() {
    return IntegrationFlows.from("routingChannel")
            .route(router())
            .get();
}

public HeaderValueRouter router() {
    HeaderValueRouter router = new HeaderValueRouter("testHeader");
    router.setChannelMapping("someHeaderValue", "channelA");
    router.setChannelMapping("someOtherHeaderValue", "channelB");
    return router;
}
----

Note that the router can be, but doesn't have to be, a `@Bean` - the flow will register it if it is not.

2) define the routing function within the DSL flow itself...

[source, java]
----
@Bean
public IntegrationFlow routerFlow2() {
    return IntegrationFlows.from("routingChannel")
            .<Message<?>, String>route(m -> m.getHeaders().get("testHeader", String.class), m -> m
                    .channelMapping("someHeaderValue", "channelA")
                    .channelMapping("someOtherHeaderValue", "channelB"),
                e -> e.id("headerValueRouter"))
            .get();
}
----

_2.
Configuration where mapping of header values to channel names
              is not required since header values themselves represent channel names_

[source,xml]
----
<int:header-value-router input-channel="routingChannel" header-name="testHeader"/>
----

[NOTE]
=====
Since Spring Integration 2.1 the behavior of resolving channels is more explicit.
For example, if you ommit the `default-output-channel` attribute and the Router was unable to resolve at least one valid channel, and any channel name resolution failures were ignored by setting `resolution-required` to `false`, then a `MessageDeliveryException` is thrown.

Basically, by default the Router must be able to route messages successfully to at least one channel.
If you really want to drop messages, you must also have `default-output-channel` set to `nullChannel`.
=====

[[router-implementations-recipientlistrouter]]
===== RecipientListRouter

A `RecipientListRouter` will send each received Message to a statically defined list of Message Channels:
[source,xml]
----
<bean id="recipientListRouter"
      class="org.springframework.integration.router.RecipientListRouter">
    <property name="channels">
        <list>
            <ref bean="channel1"/>
            <ref bean="channel2"/>
            <ref bean="channel3"/>
        </list>
    </property>
</bean>
----

Spring Integration also provides namespace support for the `RecipientListRouter` configuration (see <<configuration-namespace>>) as the example below demonstrates.

[source,xml]
----
<int:recipient-list-router id="customRouter" input-channel="routingChannel"
        timeout="1234"
        ignore-send-failures="true"
        apply-sequence="true">
  <int:recipient channel="channel1"/>
  <int:recipient channel="channel2"/>
</int:recipient-list-router>
----

The equivalent router, using Java configuration:

[source, java]
----
@ServiceActivator(inputChannel = "routingChannel")
@Bean
public RecipientListRouter router() {
    RecipientListRouter router = new RecipientListRouter();
    router.setSendTimeout(1_234L);
    router.setIgnoreSendFailures(true);
    router.setApplySequence(true);
    router.addRecipient("channel1");
    router.addRecipient("channel2");
    router.addRecipient("channel3");
    return router;
}
----

The equivalent router, using the Java DSL:

[source, java]
----
@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
            .routeToRecipients(r -> r
                    .applySequence(true)
                    .ignoreSendFailures(true)
                    .recipient("channel1")
                    .recipient("channel2")
                    .recipient("channel3")
                    .sendTimeout(1_234L))
            .get();
}
----



NOTE: The 'apply-sequence' flag here has the same effect as it does for a publish-subscribe-channel, and like a publish-subscribe-channel, it is disabled by default on the recipient-list-router.
Refer to <<channel-configuration-pubsubchannel>> for more information.

Another convenient option when configuring a `RecipientListRouter` is to use Spring Expression Language (SpEL) support as selectors for individual recipient channels.
This is similar to using a Filter at the beginning of 'chain' to act as a "Selective Consumer".
However, in this case, it's all combined rather concisely into the router's configuration.

[source,xml]
----
<int:recipient-list-router id="customRouter" input-channel="routingChannel">
    <int:recipient channel="channel1" selector-expression="payload.equals('foo')"/>
    <int:recipient channel="channel2" selector-expression="headers.containsKey('bar')"/>
</int:recipient-list-router>
----

In the above configuration a SpEL expression identified by the `selector-expression` attribute will be evaluated to determine if this recipient should be included in the recipient list for a given input Message.
The evaluation result of the expression must be a boolean.
If this attribute is not defined, the channel will always be among the list of recipients.

[[recipient-list-router-management]]
===== RecipientListRouterManagement

Starting with _version 4.1_, the `RecipientListRouter` provides several operation to manipulate with _recipients_ dynamically at runtime.
These management operations are presented by `RecipientListRouterManagement` `@ManagedResource`.
They are available using <<control-bus>> as well as via JMX:
[source,xml]
----
<control-bus input-channel="controlBus"/>

<recipient-list-router id="simpleRouter" input-channel="routingChannelA">
   <recipient channel="channel1"/>
</recipient-list-router>

<channel id="channel2"/>
----


[source,java]
----

messagingTemplate.convertAndSend(controlBus, "@'simpleRouter.handler'.addRecipient('channel2')");

----

From the application start up the `simpleRouter` will have only one `channel1` recipient.
But after the `addRecipient` command above the new `channel2` recipient will be added.
It is a "registering an interest in something that is part of the Message" use case, when we may be interested in messages from the _router_ at some time period, so we are _subscribing_ to the the `recipient-list-router` and in some point decide to _unsubscribe_ our interest.

Having the runtime management operation for the `<recipient-list-router>`, it can be configured without any `<recipient>` from the start.
In this case the behaviour of `RecipientListRouter` is the same, when there is no one matching recipient for the message: if `defaultOutputChannel` is configured, the message will be sent there, otherwise the `MessageDeliveryException` is thrown.

[[router-implementations-xpath-router]]
===== XPath Router

The XPath Router is part of the XML Module.
See _<<xml-xpath-routing>>_.

[[router-implementations-exception-router]]
===== Routing and Error handling

Spring Integration also provides a special type-based router called `ErrorMessageExceptionTypeRouter` for routing Error Messages (Messages whose `payload` is a `Throwable` instance).
`ErrorMessageExceptionTypeRouter` is very similar to the `PayloadTypeRouter`.
In fact they are almost identical.
The only difference is that while `PayloadTypeRouter` navigates the instance hierarchy of a payload instance (e.g., `payload.getClass().getSuperclass()`) to find the most specific type/channel mappings,
the `ErrorMessageExceptionTypeRouter` navigates the hierarchy of 'exception causes' (e.g., `payload.getCause()`)
to find the most specific `Throwable` type/channel mappings and uses `mappingClass.isInstance(cause)` to match the
`cause` to the class or any super class.

NOTE: Since _version 4.3_ the `ErrorMessageExceptionTypeRouter` loads all mapping classes during the initialization
phase to fail-fast for a `ClassNotFoundException`.

Below is a sample configuration for `ErrorMessageExceptionTypeRouter`.

[source,xml]
----
<int:exception-type-router input-channel="inputChannel"
                           default-output-channel="defaultChannel">
    <int:mapping exception-type="java.lang.IllegalArgumentException"
                 channel="illegalChannel"/>
    <int:mapping exception-type="java.lang.NullPointerException"
                 channel="npeChannel"/>
</int:exception-type-router>

<int:channel id="illegalChannel" />
<int:channel id="npeChannel" />
----

[[router-namespace]]
==== Configuring a Generic Router

===== Configuring a Content Based Router with XML

The "router" element provides a simple way to connect a router to an input channel and also accepts the optional `default-output-channel` attribute.
The `ref` attribute references the bean name of a custom Router implementation (extending `AbstractMessageRouter`):

[source,xml]
----
<int:router ref="payloadTypeRouter" input-channel="input1"
            default-output-channel="defaultOutput1"/>

<int:router ref="recipientListRouter" input-channel="input2"
            default-output-channel="defaultOutput2"/>

<int:router ref="customRouter" input-channel="input3"
            default-output-channel="defaultOutput3"/>

<beans:bean id="customRouterBean" class="org.foo.MyCustomRouter"/>
----

Alternatively, `ref` may point to a simple POJO that contains the @Router annotation (see below), or the `ref` may be combined with an explicit `method` name.
Specifying a `method` applies the same behavior described in the @Router annotation section below.

[source,xml]
----
<int:router input-channel="input" ref="somePojo" method="someMethod"/>
----

Using a `ref` attribute is generally recommended if the custom router implementation is referenced in other `<router>` definitions.
However if the custom router implementation should be scoped to a single definition of the `<router>`, you may provide an inner bean definition:

[source,xml]
----
<int:router method="someMethod" input-channel="input3"
            default-output-channel="defaultOutput3">
    <beans:bean class="org.foo.MyCustomRouter"/>
</int:router>
----

NOTE: Using both the `ref` attribute and an inner handler definition in the same `<router>` configuration is not allowed, as it creates an ambiguous condition, and an Exception will be thrown.

IMPORTANT: If the "ref" attribute references a bean that extends `AbstractMessageProducingHandler` (such as routers provided by the framework itself), the configuration is optimized referencing the router directly.
In this case, each "ref" must be to a separate bean instance (or a `prototype`-scoped bean), or use the inner `<bean/>` configuration type.
However, this optimization only applies if you don't provide any router-specific attributes in the router XML definition.
If you inadvertently reference the same message handler from multiple beans, you will get a configuration exception.

The equivalent router, using Java Configuration:

[source, java]
----
@Bean
@Router(inputChannel = "routingChannel")
public AbstractMessageRouter myCustomRouter() {
    return new AbstractMessageRouter() {

        @Override
        protected Collection<MessageChannel> determineTargetChannels(Message<?> message) {
            return // determine channel(s) for message
        }

    };
}
----

The equivalent router, using the Java DSL:

[source, java]
----
@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
            .route(myCustomRouter())
            .get();
}

public AbstractMessageRouter myCustomRouter() {
    return new AbstractMessageRouter() {

        @Override
        protected Collection<MessageChannel> determineTargetChannels(Message<?> message) {
            return // determine channel(s) for message
        }

    };
}
----

or, if you can route on just some message payload data:

[source, java]
----
@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
            .route(String.class, p -> p.contains("foo") ? "fooChannel" : "barChannel")
            .get();
}
----

_Routers and the Spring Expression Language (SpEL)_

Sometimes the routing logic may be simple and writing a separate class for it and configuring it as a bean may seem like overkill.
As of Spring Integration 2.0 we offer an alternative where you can now use SpEL to implement simple computations that previously required a custom POJO router.

NOTE: For more information about the Spring Expression Language, please refer to the respective chapter in the Spring Framework Reference Documentation at:

Generally a SpEL expression is evaluated and the result is mapped to a channel:

[source,xml]
----
<int:router input-channel="inChannel" expression="payload.paymentType">
    <int:mapping value="CASH" channel="cashPaymentChannel"/>
    <int:mapping value="CREDIT" channel="authorizePaymentChannel"/>
    <int:mapping value="DEBIT" channel="authorizePaymentChannel"/>
</int:router>
----

The equivalent router, using Java Configuration:

[source, java]
----
@Router(inputChannel = "routingChannel")
@Bean
public ExpressionEvaluatingRouter router() {
    ExpressionEvaluatingRouter router = new ExpressionEvaluatingRouter("payload.paymentType");
    router.setChannelMapping("CASH", "cashPaymentChannel");
    router.setChannelMapping("CREDIT", "authorizePaymentChannel");
    router.setChannelMapping("DEBIT", "authorizePaymentChannel");
    return router;
}
----

The equivalent router, using the Java DSL:

[source, java]
----
@Bean
public IntegrationFlow routerFlow() {
    return IntegrationFlows.from("routingChannel")
        .route("payload.paymentType", r -> r
            .channelMapping("CASH", "cashPaymentChannel")
            .channelMapping("CREDIT", "authorizePaymentChannel")
            .channelMapping("DEBIT", "authorizePaymentChannel"))
        .get();
}
----

To simplify things even more, the SpEL expression may evaluate to a channel name:

[source,xml]
----
<int:router input-channel="inChannel" expression="payload + 'Channel'"/>
----

In the above configuration the result channel will be computed by the SpEL expression which simply concatenates the value of the `payload` with the literal String 'Channel'.

Another value of SpEL for configuring routers is that an expression can actually return a `Collection`, effectively making every `<router>` a _Recipient List Router_.
Whenever the expression returns multiple channel values the Message will be forwarded to each channel.

[source,xml]
----
<int:router input-channel="inChannel" expression="headers.channels"/>
----

In the above configuration, if the Message includes a header with the name 'channels' the value of which is a `List` of channel names then the Message will be sent to each channel in the list.
You may also find _Collection Projection_ and _Collection Selection_ expressions useful to select multiple channels.
For further information, please see:

* http://static.springsource.org/spring/docs/current/spring-framework-reference/html/expressions.html#expressions-collection-projection[Collection Projection]
* http://static.springsource.org/spring/docs/current/spring-framework-reference/html/expressions.html#expressions-collection-selection[Collection Selection]



[[router-annotation]]
===== Configuring a Router with Annotations

When using `@Router` to annotate a method, the method may return either a `MessageChannel` or `String` type.
In the latter case, the endpoint will resolve the channel name as it does for the default output channel.
Additionally, the method may return either a single value or a collection.
If a collection is returned, the reply message will be sent to multiple channels.
To summarize, the following method signatures are all valid.

[source,java]
----
@Router
public MessageChannel route(Message message) {...}

@Router
public List<MessageChannel> route(Message message) {...}

@Router
public String route(Foo payload) {...}

@Router
public List<String> route(Foo payload) {...}
----

In addition to payload-based routing, a Message may be routed based on metadata available within the message header as either a property or attribute.
In this case, a method annotated with `@Router` may include a parameter annotated with `@Header` which is mapped to a header value as illustrated below and documented in <<annotations>>.

[source,java]
----
@Router
public List<String> route(@Header("orderStatus") OrderStatus status)
----

NOTE: For routing of XML-based Messages, including XPath support, see <<xml>>.

Also see <<java-dsl-routers>> in Java DSL chapter for more information about routers configuration.

[[dynamic-routers]]
==== Dynamic Routers

So as you can see, Spring Integration provides quite a few different router configurations for common _content-based routing_ use cases as well as the option of implementing custom routers as POJOs.
For example `PayloadTypeRouter` provides a simple way to configure a router which computes `channels` based on the `payload type` of the incoming Message while `HeaderValueRouter` provides the same convenience in configuring a router which computes `channels` by evaluating the value of a particular Message Header.
There are also _expression-based_ (SpEL) routers where the `channel` is determined based on evaluating an expression.
Thus, these type of routers exhibit some dynamic characteristics.

However these routers all require _static configuration_.
Even in the case of expression-based routers, the expression itself is defined as part of the router configuration which means that_the same expression operating on the same value will always result in the computation of the same channel_.
This is acceptable in most cases since such routes are well defined and therefore predictable.
But there are times when we need to change router configurations dynamically so message flows may be routed to a different channel.

_Example:_

You might want to bring down some part of your system for maintenance and temporarily re-reroute messages to a different message flow.
Or you may want to introduce more granularity to your message flow by adding another route to handle a more concrete type of `java.lang.Number` (in the case of `PayloadTypeRouter`).

Unfortunately with static router configuration to accomplish this, you would have to bring down your entire application, change the configuration of the router (change routes) and bring it back up.
This is obviously not the solution.

The http://www.eaipatterns.com/DynamicRouter.html[Dynamic Router] pattern describes the mechanisms by which one can change/configure routers dynamically without bringing down the system or individual routers. 

Before we get into the specifics of how this is accomplished in Spring Integration, let's quickly summarize the typical flow of the router, which consists of 3 simple steps:

* _Step 1_ - Compute `channel identifier` which is a value calculated by the router once it receives the Message.
Typically it is a `String` or and instance of the actual `MessageChannel`.
* _Step 2_ - Resolve `channel identifier` to `channel name`.
We'll describe specifics of this process in a moment.
* _Step 3_ - Resolve `channel name` to the actual `MessageChannel`



There is not much that can be done with regard to dynamic routing if Step 1 results in the actual instance of the `MessageChannel`, simply because the `MessageChannel` is the _final product_ of any router's job.
However, if Step 1 results in a `channel identifier` that is not an instance of `MessageChannel`, then there are quite a few possibilities to influence the process of deriving the `Message Channel`.
Lets look at couple of the examples in the context of the 3 steps mentioned above: 

_Payload Type Router_

[source,xml]
----
<int:payload-type-router input-channel="routingChannel">
    <int:mapping type="java.lang.String"  channel="channel1" />
    <int:mapping type="java.lang.Integer" channel="channel2" />
</int:payload-type-router>
----

Within the context of the Payload Type Router the 3 steps mentioned above would be realized as:

* _Step 1_ - Compute `channel identifier` which is the fully qualified name of the payload type (e.g., java.lang.String).
* _Step 2_ - Resolve `channel identifier` to `channel name` where the result of the previous step is used to select the appropriate value from the _payload type mapping_ defined via `mapping` element.
* _Step 3_ - Resolve `channel name` to the actual instance of the `MessageChannel` as a reference to a bean within the Application Context (which is hopefully a `MessageChannel`) identified by the result of the previous step.



In other words, each step feeds the next step until the process completes.

_Header Value Router_

[source,xml]
----
<int:header-value-router input-channel="inputChannel" header-name="testHeader">
    <int:mapping value="foo" channel="fooChannel" />
    <int:mapping value="bar" channel="barChannel" />
</int:header-value-router>
----

Similar to the PayloadTypeRouter:

* _Step 1_ - Compute `channel identifier` which is the value of the header identified by the `header-name` attribute.
* _Step 2_ - Resolve `channel identifier` to `channel name` where the result of the previous step is used to select the appropriate value from the _general mapping_ defined via `mapping` element.
* _Step 3_ - Resolve `channel name` to the actual instance of the `MessageChannel` as a reference to a bean within the Application Context (which is hopefully a `MessageChannel`) identified by the result of the previous step.



The above two configurations of two different router types look almost identical.
However if we look at the alternate configuration of the `HeaderValueRouter` we clearly see that there is no `mapping` sub element:

[source,xml]
----
<int:header-value-router input-channel="inputChannel" header-name="testHeader">
----

But the configuration is still perfectly valid.
So the natural question is what about the mapping in the Step 2?

What this means is that Step 2 is now an optional step.
If `mapping` is not defined then the `channel identifier` value computed in Step 1 will automatically be treated as the `channel name`, which will now be resolved to the actual `MessageChannel` as in Step 3. 
What it also means is that Step 2 is one of the key steps to provide dynamic characteristics to the routers, since it introduces a process which _allows you to change the way 'channel identifier' resolves to 'channel name'_, thus influencing the process of determining the final instance of the `MessageChannel` from the initial `channel identifier`. 

_For Example:_

In the above configuration let's assume that the `testHeader` value is 'kermit' which is now a `channel identifier` (Step 1).
Since there is no mapping in this router, resolving this `channel identifier` to a `channel name` (Step 2) is impossible and this `channel identifier` is now treated as `channel name`.
However what if there was a mapping but for a different value?
The end result would still be the same and that is: _if a new value cannot be determined through the process of resolving the 'channel identifier' to a 'channel name', such 'channel identifier' becomes 'channel name'._

So all that is left is for Step 3 to resolve the `channel name` ('kermit') to an actual instance of the `MessageChannel` identified by this name.
That basically involves a bean lookup for the name provided.
So now all messages which contain the header/value pair as `testHeader=kermit` are going to be routed to a `MessageChannel` whose bean name (id) is 'kermit'.

But what if you want to route these messages to the 'simpson' channel? Obviously changing a static configuration will work, but will also require bringing your system down.
However if you had access to the `channel identifier` map, then you could just introduce a new mapping where the header/value pair is now `kermit=simpson`, thus allowing Step 2 to treat 'kermit' as a `channel identifier` while resolving it to 'simpson' as the `channel name` .

The same obviously applies for `PayloadTypeRouter`, where you can now remap or remove a particular _payload type
            mapping_.
In fact, it applies to every other router, including _expression-based_ routers, since their computed values will now have a chance to go through Step 2 to be additionally resolved to the actual `channel name`.

Any router that is a subclass of the `AbstractMappingMessageRouter` (which includes most framework defined routers) is a Dynamic Router simply because the `channelMapping` is defined at the `AbstractMappingMessageRouter` level.
That map's setter method is exposed as a public method along with 'setChannelMapping' and 'removeChannelMapping' methods.
These allow you to change/add/remove router mappings at runtime as long as you have a reference to the router itself.
It also means that you could expose these same configuration options via JMX (see <<jmx>>) or the Spring Integration ControlBus (see <<control-bus>>) functionality. 

[[dynamic-routers-control-bus]]
===== Manage Router Mappings using the Control Bus

One way to manage the router mappings is through the http://www.eaipatterns.com/ControlBus.html[Control Bus] pattern which exposes a Control Channel where you can send control messages to manage and monitor Spring Integration components, including routers.

NOTE: For more information about the Control Bus, please see chapter _<<control-bus>>_.

Typically you would send a control message asking to invoke a particular operation on a particular managed component (e.g.
router).
Two managed operations (methods) that are specific to changing the router resolution process are:

* `public void setChannelMapping(String key, String channelName)` - will allow you to add a new or modify an existing mapping between `channel identifier` and `channel name`
* `public void removeChannelMapping(String key)` - will allow you to remove a particular channel mapping, thus disconnecting the relationship between `channel identifier` and `channel name`



Note that these methods can be used for simple changes (updating a single route or adding/removing a route).
However, if you want to remove one route and add another, the updates are not atomic.
This means the routing table may be in an indeterminate state between the updates.
Starting with _version 4.0_, you can now use the control bus to update the entire routing table atomically.

* `public Map<String, String>getChannelMappings()` returns the current mappings.
* `public void replaceChannelMappings(Properties channelMappings)` updates the mappings.
Notice that the parameter is a properties object; this allows the use of the inbuilt `StringToPropertiesConverter` by a control bus command, for example:
[source]
----
"@'router.handler'.replaceChannelMappings('foo=qux \n baz=bar')"
----

 - note that each mapping is separated by a newline character (`\n`).
For programmatic changes to the map, it is recommended that the `setChannelMappings` method is used instead, for type-safety.
Any non-String keys or values passed into `replaceChannelMappings` are ignored.



[[dynamic-routers-jmx]]
===== Manage Router Mappings using JMX

You can also expose a router instance with Spring's JMX support, and then use your favorite JMX client (e.g., JConsole) to manage those operations (methods) for changing the router's configuration.

NOTE: For more information about Spring Integration's JMX support, please see chapter _<<jmx>>_.

[[routing-slip]]
===== Routing Slip

Starting with _version 4.1_, Spring Integration provides an implementation of the http://www.eaipatterns.com/RoutingTable.html[Routing Slip] Enterprise Integration Pattern.
It is implemented as a `routingSlip` message header which is used to determine the next channel in `AbstractMessageProducingHandler` s, when an `outputChannel` isn't specified for the endpoint.
This pattern is useful in complex, dynamic, cases when it can become difficult to configure multiple routers to determine message flow.
When a message arrives at an endpoint that has no `output-channel`, the `routingSlip` is consulted to determine the next channel to which the message will be sent.
When the routing slip is exhausted, normal `replyChannel` processing resumes.

Configuration for the _Routing Slip_ is presented as a `HeaderEnricher` option - a _semicolon-separated_ Routing Slip `path` entries:

[source,xml]
----
<util:properties id="properties">
    <beans:prop key="myRoutePath1">channel1</beans:prop>
    <beans:prop key="myRoutePath2">request.headers[myRoutingSlipChannel]</beans:prop>
</util:properties>

<context:property-placeholder properties-ref="properties"/>

<header-enricher input-channel="input" output-channel="process">
    <routing-slip
        value="${myRoutePath1}; @routingSlipRoutingPojo.get(request, reply);
               routingSlipRoutingStrategy; ${myRoutePath2}; finishChannel"/>
</header-enricher>
----

In this sample we have:

* A `<context:property-placeholder>` configuration to demonstrate that the entries in the Routing Slip `path` can be specified as resolvable keys.
* The `<header-enricher>` `<routing-slip>` sub-element is used to populate the `RoutingSlipHeaderValueMessageProcessor` to the `HeaderEnricher` handler.
* The `RoutingSlipHeaderValueMessageProcessor` accepts a String array of resolved Routing Slip `path` entries and returns (from `processMessage()`) a `singletonMap` with the `path` as `key` and `0` as initial `routingSlipIndex`.



Routing Slip `path` entries can contain `MessageChannel` bean names, `RoutingSlipRouteStrategy` bean names and also Spring expressions (SpEL).
The `RoutingSlipHeaderValueMessageProcessor` checks each Routing Slip `path` entry against the `BeanFactory` on the first `processMessage` invocation.
It converts entries, which aren't bean names in the application context, to `ExpressionEvaluatingRoutingSlipRouteStrategy` instances.
`RoutingSlipRouteStrategy` entries are invoked multiple times, until they return null, or an empty String.

Since the _Routing Slip_ is involved in the `getOutputChannel` process we have a _request-reply_ context.
The `RoutingSlipRouteStrategy` has been introduced to determine the next `outputChannel` using the `requestMessage`, as well as the `reply` object.
An implementation of this strategy should be registered as a bean in the application context and its bean name is used in the Routing Slip `path`.
The `ExpressionEvaluatingRoutingSlipRouteStrategy` implementation is provided.
It accepts a SpEL expression, and an internal `ExpressionEvaluatingRoutingSlipRouteStrategy.RequestAndReply` object is used as the _root object_ of the evaluation context.
This is to avoid the overhead of `EvaluationContext` creation for each `ExpressionEvaluatingRoutingSlipRouteStrategy.getNextPath()` invocation.
It is a simple Java Bean with two properties - `Message<?> request` and `Object reply`.
With this expression implementation, we can specify Routing Slip `path` entries using SpEL (`@routingSlipRoutingPojo.get(request, reply)`, `request.headers[myRoutingSlipChannel]`) avoiding a bean definition for the `RoutingSlipRouteStrategy`.

NOTE: The `requestMessage` argument is always a `Message<?>`; depending on context, the reply object may be a
`Message<?>`, an `AbstractIntegrationMessageBuilder` or an arbitrary application domain object (if, for example,
it is returned by a POJO method invoked by a service activator).
In the first two cases, the usual "message" properties are available (`payload` and `headers`) when using SpEL (or
a Java implementation).
When an arbitrary domain object, these properties are, obviously, not available.
Care should be taken when using routing slips in conjunction with POJO methods if the result is used to determine the
next path.

IMPORTANT: If a _Routing Slip_ is involved in a distributed environment - cross-JVM application, `request-reply` through a Message Broker (e.g.
<<amqp>>, <<jms>>), or persistence `MessageStore` (<<message-store>>) is used in the integration flow, etc., - it is recommended to *not* use _inline_ expressions for the Routing Slip `path`.
The framework (`RoutingSlipHeaderValueMessageProcessor`) converts them to `ExpressionEvaluatingRoutingSlipRouteStrategy` objects and they are used in the `routingSlip` message header.
Since this class isn't `Serializable` (and it can't be, because it depends on the `BeanFactory`) the entire Message becomes non-serializable and in any distributed operation we end up with `NotSerializableException`.
To overcome this limitation, register an `ExpressionEvaluatingRoutingSlipRouteStrategy` bean with the desired SpEL and use its bean name in the Routing Slip `path` configuration.

For Java configuration, simply add a `RoutingSlipHeaderValueMessageProcessor` instance to the `HeaderEnricher` bean definition:

[source,java]
----
@Bean
@Transformer(inputChannel = "routingSlipHeaderChannel")
public HeaderEnricher headerEnricher() {
    return new HeaderEnricher(Collections.singletonMap(IntegrationMessageHeaderAccessor.ROUTING_SLIP,
            new RoutingSlipHeaderValueMessageProcessor("myRoutePath1",
                                                       "@routingSlipRoutingPojo.get(request, reply)",
                                                       "routingSlipRoutingStrategy",
                                                       "request.headers[myRoutingSlipChannel]",
                                                       "finishChannel")));
}
----

The _Routing Slip_ algorithm works as follows when an endpoint produces a reply and there is no `outputChannel` defined:

* The `routingSlipIndex` is used to get a value from the Routing Slip `path` list.
* If the value by `routingSlipIndex` is `String`, it is used to get a bean from `BeanFactory`.
* If a returned bean is an instance of `MessageChannel`, it is used as the next `outputChannel` and the `routingSlipIndex` is incremented in the reply message header (the Routing Slip `path` entries remain unchanged).
* If a returned bean is an instance of `RoutingSlipRouteStrategy` and its `getNextPath` doesn't return an empty String, that result is used a bean name for the next `outputChannel`.
The `routingSlipIndex` remains unchanged.
* If `RoutingSlipRouteStrategy.getNextPath` returns an empty String, the `routingSlipIndex` is incremented and the `getOutputChannelFromRoutingSlip` is invoked recursively for the next Routing Slip `path` item;
* If the next Routing Slip `path` entry isn't a String it must be an instance of `RoutingSlipRouteStrategy`;
* When the `routingSlipIndex` exceeds the size of the Routing Slip `path` list, the algorithm moves to the default behavior for the standard `replyChannel` header.



[[process-manager]]
===== Process Manager Enterprise Integration Pattern

The EIP also defines the http://www.eaipatterns.com/ProcessManager.html[Process Manager] pattern.
This pattern can now easily be implemented using custom _Process Manager_ logic encapsulated in a `RoutingSlipRouteStrategy` within the routing slip.
In addition to a bean name, the `RoutingSlipRouteStrategy` can return any `MessageChannel` object; and there is no requirement that this `MessageChannel` instance is a bean in the application context.
This way, we can provide powerful dynamic routing logic, when there is no prediction which channel should be used; a `MessageChannel` can be created within the `RoutingSlipRouteStrategy` and returned.
A `FixedSubscriberChannel` with an associated `MessageHandler` implementation is good combination for such cases.
For example we can route to a https://github.com/reactor/reactor/wiki/Streams[Reactor Stream]:

[source,java]
----
@Bean
public PollableChannel resultsChannel() {
    return new QueueChannel();
}
@Bean
public RoutingSlipRouteStrategy routeStrategy() {
    return (requestMessage, reply) -> requestMessage.getPayload() instanceof String
            ? new FixedSubscriberChannel(m ->
            Mono.just((String) m.getPayload())
                    .map(String::toUpperCase)
                    .subscribe(v -> messagingTemplate().convertAndSend(resultsChannel(), v)))
            : new FixedSubscriberChannel(m ->
            Mono.just((Integer) m.getPayload())
                    .map(v -> v * 2)
                    .subscribe(v -> messagingTemplate().convertAndSend(resultsChannel(), v)));
}
----
