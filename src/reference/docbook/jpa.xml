<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="jpa"
	xmlns:xlink="http://www.w3.org/1999/xlink">
	<title>JPA Support</title>
	<para>
		Spring Integration's JPA (Java Persistence API) module provides components
		for performing various database operations using JPA. The following
		components are provided:
	</para>
	<itemizedlist>
		<listitem>
			<para><emphasis><link linkend='jpa-inbound-channel-adapter'>Inbound Channel Adapter</link></emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis><link linkend='jpa-outbound-channel-adapter'>Outbound Channel Adapter</link></emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis><link linkend='jpa-updating-outbound-gateway'>Updating Outbound Gateway</link></emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis><link linkend='jpa-retrieving-outbound-gateway'>Retrieving Outbound Gateway</link></emphasis></para>
		</listitem>
	</itemizedlist>
	<para>
		These components can be used to perform
		<emphasis>select</emphasis>,
		<emphasis>create</emphasis>,
		<emphasis>update</emphasis> and
		<emphasis>delete</emphasis>
		operations on the targeted databases by sending/receiving messages to them.
	</para>
	<para>
		The JPA <emphasis>Inbound Channel Adapter</emphasis> lets you poll and
		retrieve (select) data from the database using JPA whereas the JPA
		<emphasis>Outbound Channel Adapter</emphasis> lets you create, update
		and delete entities.
	</para>
	<para>
		Outbound Gateways for JPA can be used to persist entities to the
		database, yet allowing you to continue with the flow and execute further
		components downstream. Similarly, you can use an Outbound Gateway to retrieve
		entities from the database.
	</para>
	<para>
		For example, you may use the Outbound Gateway, which receives a Message
		with a user Id as payload on its request channel, to query the database
		and retrieve the User entity and pass it downstream for further processing.
	</para>
	<para>
		Recognizing these semantic differences, Spring Integration provides 2 separate
		JPA Outbound Gateways:
	</para>
	<itemizedlist>
		<listitem>
			<para><emphasis>Retrieving Outbound Gateway</emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis>Updating Outbound Gateway</emphasis></para>
		</listitem>
	</itemizedlist>
	<para><emphasis>Functionality</emphasis></para>
	<para>
		All JPA components perform their respective JPA operations by using
		either one of the following:
	</para>
	<itemizedlist>
		<listitem>
			<para><emphasis>Entity classes</emphasis></para>
		</listitem>
		<listitem>
			<para>
				<emphasis>
					Java Persistence Query Language (JPQL) for update, select and
					delete (inserts are not supported by JPQL)
				</emphasis>
			</para>
		</listitem>
		<listitem>
			<para><emphasis>Native Query</emphasis></para>
		</listitem>
		<listitem>
			<para><emphasis>Named Query</emphasis></para>
		</listitem>
	</itemizedlist>
	<para>
		In the following sections we will describe each of these components in
		more detail.
	</para>
	<section id="jpa-supported-persistence-providers">
		<title>Supported Persistence Providers</title>
		<para>
			The Spring Integration JPA support has been tested using the following
			persistence providers:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>Hibernate</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>OpenJPA</emphasis>
				</para>
			</listitem>
			<listitem>
				<para><emphasis>EclipseLink</emphasis></para>
			</listitem>
		</itemizedlist>
		<para>
			When using a persistence provider, please ensure that the provider
			is compatible with JPA 2.0.
		</para>
	</section>
	<section id="jpa-java-implementation">
		<title>Java Implementation</title>
		<para>Each of the provided components will use the
			<classname>o.s.i.jpa.core.JpaExecutor</classname>
			class which in turn will use an implementation of the
			<interfacename>o.s.i.jpa.core.JpaOperations</interfacename>
			interface. <interfacename>JpaOperations</interfacename> operates like a
			typical Data Access Object (DAO) and provides methods such as
			<emphasis>find</emphasis>,
			<emphasis>persist</emphasis>,
			<emphasis>executeUpdate</emphasis> etc. For most use cases the provided
			default implementation
			<classname>o.s.i.jpa.core.DefaultJpaOperations</classname>
			should be sufficient. Nevertheless, you have the option to
			optionally specify your own implementation in case you require custom
			behavior.
		</para>
		<para>
			For initializing a <classname>JpaExecutor</classname>
			you have to use one of 3 available constructors that accept one of:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>EntityManagerFactory</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>EntityManager</emphasis> or
				</para>
			</listitem>
			<listitem>
				<para><emphasis>JpaOperations</emphasis></para>
			</listitem>
		</itemizedlist>
		<note>
			The XML Namespace Support described further below is also very
			flexible and provides configuration attributes for
			each JPA component to pass in an <emphasis>EntityManagerFactory</emphasis>,
			<emphasis>EntityManager</emphasis> or <emphasis>JpaOperations</emphasis>
			reference.
		</note>
		<para><emphasis>Java Configuration Example</emphasis></para>
		<para>
			The following example of a JPA <emphasis>Retrieving Outbound Gateway</emphasis> is configured
			purely through Java. In typical usage scenarios you will most likely prefer
			the XML Namespace Support described further below. However, the example
			illustrates how the classes are wired up. Understanding the inner
			workings can also be very helpful for debugging or customizing
			the individual JPA components.
		</para>

		<para>
			First, we instantiate a <classname>JpaExecutor</classname> using an
			<interfacename>EntityManager</interfacename> as constructor argument.
			The <classname>JpaExecutor</classname> is then in return used as
			constructor argument for the <classname>o.s.i.jpa.outbound.JpaOutboundGateway</classname>
			and the <classname>JpaOutboundGateway</classname> will be passed as constructor
			argument into the <classname>EventDrivenConsumer</classname>.
		</para>

		<programlisting language="xml"><![CDATA[<bean id="jpaExecutor" class="o.s.i.jpa.core.JpaExecutor">
    <constructor-arg name="entityManager" ref="entityManager"/>
    <property name="entityClass"        value="o.s.i.jpa.test.entity.StudentDomain"/>
    <property name="jpaQuery"           value="select s from Student s where s.id = :id"/>
    <property name="expectSingleResult" value="true"/>
    <property name="jpaParameters" >
        <util:list>
            <bean class="org.springframework.integration.jpa.support.JpaParameter">
                <property name="name"       value="id"/>
                <property name="expression" value="payload"/>
            </bean>
        </util:list>
    </property>
</bean>

<bean id="jpaOutboundGateway" class="o.s.i.jpa.outbound.JpaOutboundGateway">
    <constructor-arg ref="jpaExecutor"/>
    <property        name="gatewayType"   value="RETRIEVING"/>
    <property        name="outputChannel" ref="studentReplyChannel"/>
</bean>

<bean id="getStudentEndpoint"
      class="org.springframework.integration.endpoint.EventDrivenConsumer">
    <constructor-arg name="inputChannel" ref="getStudentChannel"/>
    <constructor-arg name="handler"      ref="jpaOutboundGateway"/>
</bean>]]></programlisting>
		<note>
			For more examples of constructing JPA components purely through Java,
			see the JUnit test-cases for the JPA Adapters.
		</note>
	</section>
	<section id="jpa-namespace-support">
		<title>Namespace Support</title>
		<para>
			When using XML namespace support, the underlying parser classes will
			instantiate the relevant Java classes for you. Thus, you typically don't have to
			deal with the inner workings of the JPA adapter. This section will
			document the XML Namespace Support provided by the Spring Integration
			and will show you how to use the XML Namespace Support to configure
			the Jpa components.
		</para>
		<section id="jpa-namespace-support-common-attributes">
			<title>Common XML Namespace Configuration Attributes</title>
			<para>
				Certain configuration parameters are shared amongst all JPA components and are described below:
			</para>

			<para><emphasis role="bold">auto-startup</emphasis></para>
			<para>
				Lifecycle attribute signaling if this component should
				be started during Application Context startup.
				Defaults to <code>true</code>.
				<emphasis>Optional</emphasis>.
			</para>

			<para><emphasis role="bold">id</emphasis></para>
			<para>
				Identifies the underlying Spring bean definition, which
				is an instance of either <classname>EventDrivenConsumer</classname>
				or <classname>PollingConsumer</classname>.
				<emphasis>Optional</emphasis>.
			</para>

			<para><emphasis role="bold">entity-manager-factory</emphasis></para>
			<para>
				The reference to the JPA Entity Manager Factory
				that will be used by the adapter to create the <classname>EntityManager</classname>.
				Either this attribute or the <emphasis>entity-manager</emphasis> attribute
				or the <emphasis>jpa-operations</emphasis> attribute must be provided.
			</para>

			<para><emphasis role="bold">entity-manager</emphasis></para>
			<para>
				The reference to the JPA Entity Manager that will be used by
				the component.
				Either this attribute or the <emphasis>enity-manager-factory</emphasis> attribute
				or the <emphasis>jpa-operations</emphasis> attribute must be provided.
			</para>
			<note>
				Usually your Spring Application Context only defines a
				JPA Entity Manager Factory and the EntityManager is injected using
				the @PersistenceContext annotation. This, however, is not applicable for
				the Spring Integration JPA components.

				Usually, injecting the JPA Entity Manager Factory will be best but in
				case you want to inject an EntityManager explicitly, you have to define
				a <classname>SharedEntityManagerBean</classname>. For more information,
				please see the relevant
				<ulink url="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html">JavaDoc</ulink>.
			</note>
			<programlisting language="xml"><![CDATA[<bean id="entityManager"
      class="org.springframework.orm.jpa.support.SharedEntityManagerBean">
    <property name="entityManagerFactory" ref="entityManagerFactoryBean" />
</bean>]]></programlisting>
			<para><emphasis role="bold">jpa-operations</emphasis></para>
			<para>
				Reference to a bean implementing the
				<interfacename>JpaOperations</interfacename> interface. In rare cases
				it might be advisable to provide your own implementation
				of the <interfacename>JpaOperations</interfacename> interface, instead
				of relying on the default implementation
				<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname>.
				As <interfacename>JpaOperations</interfacename> wraps the necessary
				datasource; the JPA Entity Manager or JPA Entity Manager Factory
				must not be provided, if the <emphasis>jpa-operations</emphasis>
				attribute is used.
			</para>

			<para><emphasis role="bold">entity-class</emphasis></para>
			<para>
				The fully qualified name of the entity class. The exact semantics of
				this attribute vary, depending on whether we are performing a persist/update
				operation or whether we are retrieving objects from the database.
			</para>
			<para>
				When retrieving data, you can specify the
				<emphasis>entity-class</emphasis> attribute to indicate that you would
				like to retrieve objects of this type from the database. In that case
				you must not define any of the query attributes (
				<emphasis>jpa-query</emphasis>,
				<emphasis>native-query</emphasis> or
				<emphasis>named-query</emphasis>
				)
			</para>
			<para>
				When persisting data, the <emphasis>entity-class</emphasis> attribute
				will indicate the type of object to persist. If not specified
				(for persist operations) the entity class will be automatically retrieved
				from the Message's payload.
			</para>

			<para><emphasis role="bold">jpa-query</emphasis></para>
			<para>
				Defines the JPA query (Java Persistence Query Language) to be used.
			</para>

			<para><emphasis role="bold">native-query</emphasis></para>
			<para>
				Defines the native SQL query to be used.
			</para>

			<para><emphasis role="bold">named-query</emphasis></para>
			<para>
				This attribute refers to a named query. A named query can
				either be defined in Native SQL or JPAQL but the underlying JPA
				persistence provider handles that distinction internally.
			</para>

		</section>

		<section id="jpa-parameters">
			<title>Providing JPA Query Parameters</title>
			<para>
				For providing parameters, the <emphasis>parameter</emphasis> XML
				sub-element can be used. It provides a mechanism to provide
				parameters for the queries that are either based on the Java
				Persistence Query Language (JPQL) or native SQL queries. Parameters
				can also be provided for Named Queries.
			</para>

			<para><emphasis>Expression based Parameters</emphasis></para>
			<programlisting language="xml"><![CDATA[<int-jpa:parameter expression="payload.name" name="firstName"/>]]></programlisting>

			<para><emphasis>Value based Parameters</emphasis></para>
			<programlisting language="xml"><![CDATA[<int-jpa:parameter name="name" type="java.lang.String" value="myName"/>]]></programlisting>

			<para><emphasis>Positional Parameters</emphasis></para>
			<programlisting language="xml"><![CDATA[<int-jpa:parameter expression="payload.name"/>
<int-jpa:parameter type="java.lang.Integer" value="21"/>]]></programlisting>
		</section>

		<section id="jpa-transactions">
			<title>Transaction Handling</title>
			<para>
				All JPA operations like Insert, Update and Delete require a transaction to be active whenever they are
				performed. For Inbound Channel Adapters there is nothing special to be done, it is similar
				to the way we configure transaction managers with pollers used with other inbound channel
				adapters.The xml snippet below shows a sample where a transaction manager is configured with
				the poller used with an <emphasis>Inbound Channel Adapter</emphasis>.
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:inbound-channel-adapter
    channel="inboundChannelAdapterOne"
    entity-manager="em"
    auto-startup="true"
    jpa-query="select s from Student s"
    expect-single-result="true"
    delete-after-poll="true">
    <int:poller fixed-rate="2000" >
        <int:transactional propagation="REQUIRED"
            transaction-manager="transactionManager"/>
    </int:poller>
</int-jpa:inbound-channel-adapter>]]></programlisting>
			<para>
				However, it may be necessary to specifically start a transaction when using an <emphasis>Outbound Channel Adapter</emphasis>/<emphasis>Gateway</emphasis>.
				If a <emphasis>DirectChannel</emphasis> is an input channel for the outbound adapter/gateway,
				and if transaction is active in the current thread of execution, the JPA operation will be
				performed in the same transaction context. We can also configure to execute this JPA operation
				in a new transaction as below.
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:outbound-gateway
    request-channel="namedQueryRequestChannel"
    reply-channel="namedQueryResponseChannel"
    named-query="updateStudentByRollNumber"
    entity-manager="em"
    gateway-type="UPDATING">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>]]>
		<emphasis role="bold">
		<![CDATA[    <int-jpa:transactional propagation="REQUIRES_NEW"
        transaction-manager="transactionManager"/>]]>
		</emphasis><![CDATA[
</int-jpa:outbound-gateway>]]></programlisting>
			<para>
				As we can see above, the <emphasis>transactional</emphasis> sub element of the outbound gateway/adapter will be
				used to specify the transaction attributes. It is optional to define this child element if
				you have <emphasis>DirectChannel</emphasis> as an input channel to the adapter and you want the
				adapter to execute the operations in the same transaction context as the caller.
				If, however, you are using an <emphasis>ExecutorChannel</emphasis>, it is required to have the
				<emphasis>transactional</emphasis> sub element as the invoking client's transaction context is not
				propagated.
			</para>
			<note>Unlike the <emphasis>transactional</emphasis> sub element of the poller which is defined
			in the spring integration's namespace, the <emphasis>transactional</emphasis> sub element for the
			outbound gateway/adapter is	defined in the jpa namespace.
			</note>
		</section>
	</section>
	<section id="jpa-inbound-channel-adapter">
		<title>Inbound Channel Adapter</title>
		<para>
              An <emphasis>Inbound Channel Adapter</emphasis> is used to execute a <emphasis>select</emphasis> query over the
              database using JPA QL and return the result. The message payload will be either a single
              entity or a <code>List</code> of entities. Below is a sample xml snippet that shows
              a sample usage of <emphasis>inbound-channel-adapter</emphasis>.
			</para>
		<programlisting language="xml"><![CDATA[<int-jpa:inbound-channel-adapter channel="inboundChannelAdapterOne" ]]><co id="inboundAdapterChannel"/><![CDATA[
                    entity-manager="em" ]]><co id="inboundAdapterEntityManager"/><![CDATA[
                    auto-startup="true" ]]><co id="inboundAdapterAutoStartup"/><![CDATA[
                    query="select s from Student s" ]]><co id="inboundAdapterQuery"/><![CDATA[
                    expect-single-result="true" ]]><co id="inboundAdapterExpectResult"/><![CDATA[
                    max-number-of-results="" ]]><co id="inboundAdapterMaxResults"/><![CDATA[
                    max-results="" ]]><co id="inboundAdapterMaxResults2"/><![CDATA[
                    max-results-expression="" ]]><co id="inboundAdapterMaxResultsExpression"/><![CDATA[
                    delete-after-poll="true" ]]><co id="inboundAdapterDeleteAfterPoll"/><![CDATA[
                    flush-after-delete="true"> ]]><co id="inboundAdapterFlushAfterDelete"/><![CDATA[
    <int:poller fixed-rate="2000" >
      <int:transactional propagation="REQUIRED" transaction-manager="transactionManager"/>
    </int:poller>
</int-jpa:inbound-channel-adapter>]]>
			</programlisting>
		<calloutlist>
                 <callout arearefs="inboundAdapterChannel">
                     <para>
                         The channel over which the <emphasis>inbound-channel-adapter</emphasis> will put the
                         messages with the payload received after executing the provided JPA QL in the
                         <emphasis>query</emphasis> attribute.
                     </para>
                 </callout>
                 <callout arearefs="inboundAdapterEntityManager">
                     <para>
                         The <classname>EntityManager</classname> instance that will be used to perform the
                         required JPA operations.
                     </para>
                 </callout>
                 <callout arearefs="inboundAdapterAutoStartup">
                     <para>
                         Attribute signalling if the component should be automatically started on startup of
                         the Application Context. The value defaults to <code>true</code>
                     </para>
                 </callout>
                 <callout arearefs="inboundAdapterQuery">
                     <para>
                         The JPA QL that needs to be executed and whose result needs to be sent out as the
                         payload of the message
                     </para>
                 </callout>
                 <callout arearefs="inboundAdapterExpectResult">
                     <para>
                         The attribute that tells if the executed JPQL query gives a single entity in the result
                         or a <classname>List</classname> of entities. If the value is set to <code>true</code>,
                         the single entity retrieved is sent as the payload of the message. If, however, multiple
                         results are returned after setting this to <code>true</code>, a
                         <classname>MessagingException</classname> is thrown. The value defaults to <code>false</code>.
                     </para>
                 </callout>
                 <callout arearefs="inboundAdapterMaxResults">
					<para>
						<emphasis>Deprecated</emphasis>. Use <code>max-results</code> instead.
						<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inboundAdapterMaxResults2">
					<para>
						This non zero, non negative integer value tells the adapter not to select more than given number
						of rows on execution of the select operation. By default, if this attribute is not set,
						all the possible records are selected by given query. This attribute is mutually exclusive with
						<code>max-results-expression</code>. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inboundAdapterMaxResultsExpression">
					<para>
						An expression, mutually exclusive with <code>max-results</code>, that can
						be used to provide an expression that will be evaluated to find the maximum number of results
						in a result set. <emphasis>Optional</emphasis>.
					</para>
				</callout>
                 <callout arearefs="inboundAdapterDeleteAfterPoll">
                     <para>
                         Set this value to <code>true</code> if you want
                         to delete the rows received after execution of the query.
                         Please ensure that the component is operating as part
                         of a transaction.

                         Otherwise, you may encounter an Exception such as:
                         <emphasis>java.lang.IllegalArgumentException: Removing
                         a detached instance ...</emphasis>
                     </para>
                 </callout>
				 <callout arearefs="inboundAdapterFlushAfterDelete">
                     <para>
                         Set this value to <code>true</code> if you want
                         to the persistence context immediately after deleting received entities
						 and if you don't want rely on the<interfacename>EntityManager</interfacename>'s flushMode.
						 The default value is set to <code>false</code>.
                     </para>
                 </callout>
		</calloutlist>
		<section id="jpaInboundChannelAdapterParameters">
				<title>Configuration Parameter Reference</title>
				<programlisting language="xml"><![CDATA[<int-jpa:inbound-channel-adapter
  auto-startup="true" ]]><co id="inAdaptAutoStart"/><![CDATA[
  channel="" ]]><co id="inAdaptChannel"/><![CDATA[
  delete-after-poll="false"  ]]><co id="inAdaptDelAftPoll"/><![CDATA[
  delete-per-row="false"  ]]><co id="inAdaptDelPerRow"/><![CDATA[
  entity-class=""  ]]><co id="inAdaptEntityClass"/><![CDATA[
  entity-manager="" ]]><co id="inAdaptEntityMgr"/><![CDATA[
  entity-manager-factory="" ]]><co id="inAdaptEntityMgrFact"/><![CDATA[
  expect-single-result="false" ]]><co id="inAdaptExpectSingleResult"/><![CDATA[
  id=""
  jpa-operations="" ]]><co id="inAdaptJpaOperation"/><![CDATA[
  jpa-query="" ]]><co id="inAdaptJpaQuery"/><![CDATA[
  named-query="" ]]><co id="inAdaptNamedQuery"/><![CDATA[
  native-query="" ]]><co id="inAdaptNativeQuery"/><![CDATA[
  parameter-source="" ]]><co id="inAdaptParamSource"/><![CDATA[
  send-timeout="" ]]><co id="inAdaptSendTimeout"/><![CDATA[>
  <int:poller ref="myPoller"/>
 </int-jpa:inbound-channel-adapter>]]></programlisting>
			<calloutlist>
				<callout arearefs="inAdaptAutoStart">
					<para>
						This <emphasis>Lifecycle</emphasis> attribute signaled if this component should be started during startup of the Application Context.
						This attribute defaults to true.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptChannel">
					<para>
						The channel to which the adapter will send a message with the payload that was received after
						performing the desired JPA operation.
					</para>
				</callout>
				<callout arearefs="inAdaptDelAftPoll">
					<para>
						A boolean flag that indicates whether the records selected are to be deleted
						after they are being polled by the adapter. By default the value is <code>false</code>,
						that is, the records will not be deleted. Please ensure that the component is operating as part of a transaction.
						Otherwise, you may encounter an Exception such as:
						<emphasis>java.lang.IllegalArgumentException: Removing a detached instance ...</emphasis>.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptDelPerRow">
					<para>
						A boolean flag that indicates whether the records can be deleted in bulk or are deleted
						one record at a time. By default the value is <code>false</code>, that is, the records are bulk deleted.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptEntityClass">
					<para>
						The fully qualified name of the entity class that would be queried from the database. The adapter will automatically
						build a JPA Query to be executed based on the entity class name provided.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptEntityMgr">
					<para>
						An instance of <classname>javax.persistence.EntityManager</classname> that will be used to perform the JPA operations. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptEntityMgrFact">
					<para>
						An instance of <classname>javax.persistence.EntityManagerFactory</classname> that will be used to obtain
						an instance of <classname>javax.persistence.EntityManager</classname> that will perform the JPA operations. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptExpectSingleResult">
					<para>
						A boolean flag indicating whether the select operation is expected to return a single result or a <classname>List</classname> of results.
						If this flag is set to <code>true</code>, the single entity selected is sent as the payload
						of the message. If multiple entities are returned, an exception is thrown.
						If <code>false</code>, the <classname>List</classname> of entities is being sent as the payload of the message.
						By default the value is <code>false</code>.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptJpaOperation">
					<para>
						An implementation of <classname>org.springframework.integration.jpa.core.JpaOperations</classname> that would be used to perform the JPA operations.
						It is recommended not to provide an implementation of your own but use the default
						<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname> implementation. Either of the
						<emphasis>entity-manager</emphasis>, <emphasis>entity-manager-factory</emphasis> or
						<emphasis>jpa-operations</emphasis> attributes is to be used. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptJpaQuery">
					<para>
						The JPA QL that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptNamedQuery">
					<para>
						The named query that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptNativeQuery">
					<para>
						The native query that will be executed by this adapter. Either of the <emphasis>jpa-query</emphasis>,
						<emphasis>named-query</emphasis>,<emphasis>entity-class</emphasis> or <emphasis>native-query</emphasis>
						attributes are to be used. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptParamSource">
					<para>
						An implementation of <classname>o.s.i.jpa.support.parametersource.ParameterSource</classname>
						which will be used to resolve the values of the parameters provided in the query. Ignored if <emphasis>entity-class</emphasis>
						attribute is provided.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="inAdaptSendTimeout">
					<para>
						Maximum amount of time in milliseconds to wait when sending a message to the channel.<emphasis>Optional</emphasis>.
					</para>
				</callout>
			</calloutlist>
		</section>
	</section>
	<section id="jpa-outbound-channel-adapter">
		<title>Outbound Channel Adapter</title>
		<para>
				The JPA Outbound channel adapter allows you to accept messages over a
				request channel. The payload can either be used as the entity to be persisted,
				or used along with the headers in parameter expressions	for a defined JPQL query to be executed.

				In the following sub sections we shall see what those possible ways of performing
				these operations are.
			</para>
		<section>
			<title>Using an Entity Class</title>
				<para>
					The XML snippet below shows how we can use the Outbound Channel
					Adapter to persist an entity to the database.
				</para>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="entityTypeChannel" ]]><co id="entityTypeChannel"/><![CDATA[
    entity-class="org.springframework.integration.jpa.test.entity.Student" ]]><co id="entityClass"/><![CDATA[
    persist-mode="PERSIST" ]]><co id="persistMode"/><![CDATA[
    entity-manager="em"/ >]]><co id="entityMgr"/></programlisting>
				<calloutlist>
					<callout arearefs="entityTypeChannel">
						<para>
							The channel over which a valid JPA entity will be
							sent to the JPA Outbound Channel Adapter.
						</para>
					</callout>
					<callout arearefs="entityClass">
						<para>
							The fully qualified name of the entity class that
							would be accepted by the adapter to be persisted
							in the database. You can actually leave off this
							attribute in most cases as the adapter can determine
							the entity class automatically from the Spring Integration
							Message payload.
						</para>
					</callout>
					<callout arearefs="persistMode">
						<para>
							The operation that needs to be done by the adapter, valid values are
							<emphasis>PERSIST</emphasis>, <emphasis>MERGE</emphasis>
							and <emphasis>DELETE</emphasis>. The default value
							is <emphasis>MERGE</emphasis>.
						</para>
					</callout>
					<callout arearefs="entityMgr">
						<para>
							The JPA entity manager to be used.
						</para>
					</callout>
				</calloutlist>
				<para>
					As we can see above these 4 attributes of the <emphasis>outbound-channel-adapter</emphasis>
					are all we need to configure it to accept entities over the input channel and process
					them to <emphasis>PERSIST</emphasis>,<emphasis>MERGE</emphasis> or <emphasis>DELETE</emphasis>
					it from the underlying data source.
				</para>
				<note>
					<para>
						As of <emphasis>Spring Integration 3.0</emphasis>,
						payloads to <emphasis>persist</emphasis> or
						<emphasis>merge</emphasis> can also be of type
						<interfacename><ulink url="http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html">java.lang.Iterable</ulink></interfacename>.
						In that case, each object returned by the
						<interfacename>Iterable</interfacename> is treated as
						an entity and persisted or merged using the underlying
						<interfacename>EntityManager</interfacename>.
						<emphasis>NULL</emphasis> values returned by the iterator are ignored.
					</para>
				</note>
		</section>
		<section>
			<title>Using JPA Query Language (JPA QL)</title>
				<para>
					We have seen in the above sub section how to perform a <emphasis>PERSIST</emphasis> action using an entity
					We will now see how to use the outbound channel adapter which uses JPA QL (Java Persistence API Query Language)
				</para>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="jpaQlChannel" ]]><co id="jpaQlInputChannel"/><![CDATA[
  jpa-query="update Student s set s.firstName = :firstName where s.rollNumber = :rollNumber" ]]><co id="jpaQlQuery"/><![CDATA[
  entity-manager="em"> ]]><co id="jpaQlEntityManager"/><![CDATA[
    <int-jpa:parameter name="firstName"  expression="payload['firstName']"/> ]]><co id="jpaQlParam"/><![CDATA[
    <int-jpa:parameter name="rollNumber" expression="payload['rollNumber']"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
				<calloutlist>
                    <callout arearefs="jpaQlInputChannel">
                        <para>
                            The input channel over which the message is being sent to the outbound
                            channel adapter
                        </para>
                    </callout>
                    <callout arearefs="jpaQlQuery">
                        <para>
                            The JPA QL that needs to be executed.This query may contain parameters that will be evaluated
                            using the <emphasis>parameter</emphasis> child tag.
                        </para>
                    </callout>
                    <callout arearefs="jpaQlEntityManager">
                        <para>
                            The entity manager used by the adapter to perform the JPA operations
                        </para>
                    </callout>
                    <callout arearefs="jpaQlParam">
                        <para>
                            This sub element, one for each parameter will be used to evaluate the value of
                            the parameter names specified in the JPA QL specified in the <emphasis>query</emphasis> attribute
                        </para>
                    </callout>
				</calloutlist>
                <para>
                    The <emphasis>parameter</emphasis> sub element accepts an attribute <emphasis>name</emphasis> which corresponds to the named parameter
                    specified in the provided JPA QL (point 2 in the above mentioned sample). The value of the parameter can either be static or can be derived
                    using an expression. The static value and the expression to derive the value is specified using
                    the <emphasis>value</emphasis> and the <emphasis>expression</emphasis> attributes respectively. These attributes
                    are mutually exclusive.
                </para>
                <para>
                    If the <emphasis>value</emphasis> attribute is specified we can provide an optional
                    <emphasis>type</emphasis> attribute. The value of this attribute is the fully qualified name of the class
                    whose value is represented by the <emphasis>value</emphasis> attribute. By default
                    the type is assumed to be a <classname>java.lang.String</classname>.
                </para>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter ... >
    <int-jpa:parameter name="level" value="2" type="java.lang.Integer"/>
    <int-jpa:parameter name="name" expression="payload['name']"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
				<para>
                    As seen in the above snippet, it is perfectly valid to use multiple <emphasis>parameter</emphasis> sub elements within an outbound channel adapter
                    tag and derive some parameters using expressions and some with static value. However, care should
                    be taken not to specify the same parameter name multiple times, and, provide one <emphasis>parameter</emphasis> sub element for
                    each named parameter specified in the JPA query. For example, we are specifying two parameters
                    <emphasis>level</emphasis> and <emphasis>name</emphasis> where <emphasis>level</emphasis> attribute is a static value of type
                    <classname>java.lang.Integer</classname>, where as the <emphasis>name</emphasis> attribute is derived from the payload of the message
                </para>
				<note>
					Though specifying <emphasis>select</emphasis> is valid for JPA QL, it makes no sense as outbound channel adapters will not be
					returning any result. If you want to select some values, consider using the outbound gateway instead.
				</note>
		</section>
		<section>
			<title>Using Native Queries</title>
				<para>
	                  <para>
	                      In this section we will see how to use native queries to perform the operations using
	                      JPA outbound channel adapter. Using native queries is similar to using JPA QL,
	                      except that the query specified here is a native database query. By choosing
	                      native queries we lose the database vendor independence which we get using JPA QL.
	                  </para>
	                  <para>
	                      One of the things we can achieve using native queries is to perform database inserts, which
	                      is not possible using JPA QL (To perform inserts we send JPA entities to the channel adapter as we have seen earlier).
	                      Below is a small xml fragment that demonstrates the use of native query to insert values in a table. Please note that we
	                      have only mentioned the important attributes below. All other attributes like <emphasis>channel</emphasis>,
	                      <emphasis>entity-manager</emphasis> and the <emphasis>parameter</emphasis> sub element has the same semantics as when we use
	                      JPA QL.
	                  </para>
	                  <important>
	                      Please be aware that named parameters may not be supported
	                      by your JPA provider in conjunction with native SQL queries.
	                      While they work fine using Hibernate, OpenJPA and EclipseLink
	                      do NOT support them: https://issues.apache.org/jira/browse/OPENJPA-111

	                      Section 3.8.12 of the JPA 2.0 spec states: "Only positional
	                      parameter binding and positional access to result items may
	                      be portably used for native queries."
	                  </important>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="nativeQlChannel"
  native-query="insert into STUDENT_TABLE(FIRST_NAME,LAST_UPDATED) values (:lastName,:lastUpdated)" ]]><co id="nativeOutboundAdapterNativeQuery"/><![CDATA[
  entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/>
    <int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
                  <calloutlist>
                      <callout arearefs="nativeOutboundAdapterNativeQuery">
                          <para>
                              The native query that will be executed by this outbound channel adapter
                          </para>
                      </callout>
                  </calloutlist>
              </para>
		</section>
		<section>
              <title>Using Named Queries</title>
              <para>
                  <para>
                      We will now see how to use named queries after seeing using entity, JPA QL and native query in previous sub sections.
                      Using named query is also very similar to using JPA QL or a native query, except that we specify a named query instead of a query.
                      Before we go further and see the xml fragment for the declaration of the <emphasis>outbound-channel-adapter</emphasis>, we will
                      see how named JPA named queries are defined.
                  </para>
                  <para>
                      In our case, if we have an entity called <classname>Student</classname>, then we have the following in the class to define
                      two named queries <emphasis>selectStudent</emphasis> and <emphasis>updateStudent</emphasis>. Below is a way to define
                      named queries using annotations
                  </para>

                  <programlisting language="java"><![CDATA[@Entity
@Table(name="Student")
@NamedQueries({
    @NamedQuery(name="selectStudent",
        query="select s from Student s where s.lastName = 'Last One'"),
    @NamedQuery(name="updateStudent",
        query="update Student s set s.lastName = :lastName,
               lastUpdated = :lastUpdated where s.id in (select max(a.id) from Student a)")
})
public class Student {

...]]></programlisting>
                <para>
                    You can alternatively use the <emphasis>orm.xml</emphasis> to define named queries as seen below
                </para>
                <programlisting language="xml"><![CDATA[<entity-mappings ...>
    ...
    <named-query name="selectStudent">
        <query>select s from Student s where s.lastName = 'Last One'</query>
    </named-query>
</entity-mappings>]]></programlisting>
                <para>
                    Now that we have seen how we can define named queries using annotations or using <emphasis>orm.xml</emphasis>, we
                    will now see a small xml fragment for defining an <emphasis>outbound-channel-adapter</emphasis> using named query
                </para>
                <programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter channel="namedQueryChannel"
            named-query="updateStudent"	]]><co id="namedQuery"/><![CDATA[
            entity-manager="em">
        <int-jpa:parameter name="lastName" expression="payload['updatedLastName']"/>
        <int-jpa:parameter name="lastUpdated" expression="new java.util.Date()"/>
</int-jpa:outbound-channel-adapter>]]></programlisting>
                <calloutlist>
                    <callout arearefs="namedQuery">
                        <para>
                            The named query that we want the adapter to execute when it receives a message over the channel
                        </para>
                    </callout>
                </calloutlist>
              </para>
		</section>
		<section id="jpaOutboundChannelAdapterParameters">
				<title>Configuration Parameter Reference</title>
				<programlisting language="xml"><![CDATA[<int-jpa:outbound-channel-adapter
  auto-startup="true" ]]><co id="outAdaptAutoStart"/><![CDATA[
  channel="" ]]><co id="outAdaptChannel"/><![CDATA[
  entity-class="" ]]><co id="outAdaptEntityClass"/><![CDATA[
  entity-manager="" ]]><co id="outAdaptEntityManager"/><![CDATA[
  entity-manager-factory="" ]]><co id="outAdaptEntityMgrFact"/><![CDATA[
  id=""
  jpa-operations="" ]]><co id="outAdaptJpaOperation"/><![CDATA[
  jpa-query="" ]]><co id="outAdaptJpaQuery"/><![CDATA[
  named-query="" ]]><co id="outAdaptNamedQuery"/><![CDATA[
  native-query="" ]]><co id="outAdaptNativeQuery"/><![CDATA[
  order="" ]]><co id="outAdaptOrder"/><![CDATA[
  parameter-source-factory=""  ]]><co id="outAdaptParamSourceFact"/><![CDATA[
  persist-mode="MERGE"  ]]><co id="outAdaptPersistMode"/><![CDATA[
  flush="true"  ]]><co id="outAdaptFlush"/><![CDATA[
  flush-size="10"  ]]><co id="outAdaptFlushSize"/><![CDATA[
  clear-on-flush="true"  ]]><co id="outAdaptclearOnFlash"/><![CDATA[
  use-payload-as-parameter-source="true"  ]]><co id="outAdaptUserPayloadAsParamSrc"/><![CDATA[
	<int:poller/>
	<int-jpa:transactional/>   ]]><co id="outAdaptTransactional"/><![CDATA[
	<int-jpa:parameter/>   ]]><co id="outAdaptParam"/><![CDATA[
</int-jpa:outbound-channel-adapter>]]></programlisting>
			<calloutlist>
				<callout arearefs="outAdaptAutoStart">
					<para>
						Lifecycle attribute signaling if this component should be started during Application Context startup. Defaults to <code>true</code>. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptChannel">
					<para>
						The channel from which the outbound adapter will receive messages for performing the desired operation.
					</para>
				</callout>
				<callout arearefs="outAdaptEntityClass">
					<para>
						The fully qualified name of the entity class for the JPA
						Operation. The attributes <emphasis>entity-class</emphasis>,
						<emphasis>query</emphasis> and <emphasis>named-query</emphasis>
						are mutually exclusive. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptEntityManager">
					<para>
						An instance of <classname>javax.persistence.EntityManager</classname> that will be used to perform the JPA operations. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptEntityMgrFact">
					<para>
						An instance of <classname>javax.persistence.EntityManagerFactory</classname> that will be used to
						obtain an instance of <classname>javax.persistence.EntityManager</classname> that will perform the JPA operations. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptJpaOperation">
					<para>
						An implementation of <classname>org.springframework.integration.jpa.core.JpaOperations</classname> that would be used to perform the JPA operations.
						It is recommended not to provide an implementation of your own but use the default
						<classname>org.springframework.integration.jpa.core.DefaultJpaOperations</classname> implementation. Either of the
						<emphasis>entity-manager</emphasis>, <emphasis>entity-manager-factory</emphasis> or
						<emphasis>jpa-operations</emphasis> attributes is to be used. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptJpaQuery">
					<para>
						The JPA QL that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptNamedQuery">
					<para>
						The named query that needs to be executed by this adapter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptNativeQuery">
					<para>
						The native query that will be executed by this adapter. Either of the <emphasis>jpa-query</emphasis>,
						<emphasis>named-query</emphasis> or <emphasis>native-query</emphasis> attributes are to be used. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptOrder">
					<para>
						The order for this consumer when multiple consumers are registered thereby
						managing load- balancing and/or failover. Optional (Defaults to <emphasis>Ordered.LOWEST_PRECEDENCE</emphasis>).
					</para>
				</callout>
				<callout arearefs="outAdaptParamSourceFact">
					<para>
						An instance of <classname>o.s.i.jpa.support.parametersource.ParameterSourceFactory</classname>
						that will be used to get an instance of <classname>o.s.i.jpa.support.parametersource.ParameterSource</classname>
						which will be used to resolve the values of the parameters provided in the query.
						Ignored if operations are performed using a JPA entity. If a parameter sub element is used, the factory must be of
						type <classname>ExpressionEvaluatingParameterSourceFactory</classname>
						located in package <classname>o.s.i.jpa.support.parametersource</classname>. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptPersistMode">
					<para>
						Accepts one of the following: <emphasis>PERSIST</emphasis>,
						<emphasis>MERGE</emphasis> or <emphasis>DELETE</emphasis>.
						Indicates the operation that the adapter needs to perform.
						Relevant only if an entity is being used for JPA operations.
						Ignored if JPA QL, named query or native query is provided. Defaults to <emphasis>MERGE</emphasis>. <emphasis>Optional</emphasis>.
					</para>
					<para>
						As of <emphasis role="bold">Spring Integration 3.0</emphasis>,
						payloads to <emphasis>persist</emphasis> or
						<emphasis>merge</emphasis> can also be of type
						<interfacename><ulink url="http://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html">java.lang.Iterable</ulink></interfacename>.
						In that case, each object returned by the
						<interfacename>Iterable</interfacename> is treated as
						an entity and persisted or merged using the underlying
						<interfacename>EntityManager</interfacename>.
						<emphasis>NULL</emphasis> values returned by the iterator are ignored.
					</para>
				</callout>
				<callout arearefs="outAdaptFlush">
					<para>
						Set this value to <code>true</code> if you want
						to flush the persistence context immediately after persist, merge or delete operations
						and don't want to rely on the <interfacename>EntityManager</interfacename>'s flushMode.
						The default value is set to <code>false</code>. Applies only if the <code>flush-size</code>
						attribute isn't specified. If this attribute is set to <code>true</code>,
						then <code>flush-size</code> will be implicitly set to <code>1</code>, if it wasn't configured to any other value.
					</para>
				</callout>
				<callout arearefs="outAdaptFlushSize">
					<para>
						Set this attribute to a value greater than '0' if you want
						to flush the persistence context immediately after persist, merge or delete operations
						and don't want to rely on the <interfacename>EntityManager</interfacename>'s flushMode.
						The default value is set to <code>0</code> which means 'no flush'.
						This attribute is geared towards messages with <interfacename>Iterable</interfacename> payloads.
						For instance, if <code>flush-size</code> is set to <code>3</code>,
						then <code>entityManager.flush()</code> is called after every third entity.
						Furthermore, <code>entityManager.flush()</code> will be called once more after the entire loop.
						There is no reason to configure the <code>flush</code>
						attribute, if the 'flush-size' attribute is specified with a value greater than '0'.
					</para>
				</callout>
				<callout arearefs="outAdaptclearOnFlash">
					<para>
						Set this value to 'true' if you want
						to clear persistence context immediately after each flush operation.
						The attribute's value is applied only if the <code>flush</code> attribute is set to
						<code>true</code> or if the <code>flush-size</code> attribute is set to a value greater than <code>0</code>.
					</para>
				</callout>
				<callout arearefs="outAdaptUserPayloadAsParamSrc">
					<para>
						If set to true, the payload of the Message will be used as a source for providing parameters.
						If false, however, the entire Message will be available as a source for parameters.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptTransactional">
					<para>
						Defines the transaction management attributes and the reference to transaction manager to be used by the JPA
						adapter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outAdaptParam">
					<para>
						One or more <emphasis>parameter</emphasis> attributes, one for each parameter used in the query. The value or expression
						provided will be evaluated to compute the value of the parameter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
			</calloutlist>
		</section>
	</section>
	<section id="jpa-outbound-gateways">
		<title>Outbound Gateways</title>
		<para>
			The JPA <emphasis>Inbound Channel Adapter</emphasis> allows you to poll a database in
			order to retrieve one or more JPA entities and the retrieved data
			is consequently used to start a Spring Integration flow using the
			retrieved data as message payload.
		</para>
		<para>
			Additionally, you may use JPA <emphasis>Outbound Channel Adapters</emphasis> at
			the end of your flow in order to persist data, essentially terminating
			the flow at the end of the persistence operation.
		</para>
		<para>
			However, how can you execute JPA persistence operation in the middle
			of a flow? For example, you may have business data that you are
			processing in your Spring Integration message flow, that you would
			like to persist, yet you still need to execute other components
			further downstream. Or instead of polling the database using a
			poller, you rather have the need to execute JPQL queries and retrieve
			data actively which then is used to being processed in subsequent
			components within your flow.
		</para>
		<para>
			This is where JPA Outbound Gateways come into play. They give you
			the ability to persist data as well as retrieving data. To facilitate
			these uses, Spring Integration provides two types of JPA Outbound
			Gateways:
		</para>
		<itemizedlist>
			<listitem><emphasis>Updating Outbound Gateway</emphasis></listitem>
			<listitem><emphasis>Retrieving Outbound Gateway</emphasis></listitem>
		</itemizedlist>
		<para>
			Whenever the Outbound Gateway is used to perform an action that
			saves, updates or soley deletes some records in the database, you
			need to use an <emphasis>Updating Outbound Gateway</emphasis> gateway.
			If for example an <emphasis>entity</emphasis> is used to persist it,
			then a merged/persisted entity is returned as a result. In
			other cases the number of records affected (updated or deleted)
			is returned instead.
		</para>
		<para>
			When retrieving (selecting) data from the database, we
			use a <emphasis>Retrieving Outbound Gateway</emphasis>.  With a
			<emphasis>Retrieving Outbound Gateway</emphasis> gateway, we can
			use either JPQL, Named Queries (native or JPQL-based) or Native
			Queries (SQL) for selecting the data and retrieving the results.
		</para>
		<para>
			An <emphasis>Updating Outbound Gateway</emphasis> is
			functionally very similar to an <emphasis>Outbound Channel Adapter</emphasis>,
			except that an <emphasis>Updating Outbound Gateway</emphasis>
			is used to send a result to the Gateway's <emphasis>reply channel</emphasis>
			after performing the given JPA operation.
		</para>
		<para>
			A <emphasis>Retrieving Outbound Gateway</emphasis>
			is quite similar to an <emphasis>Inbound Channel Adapter</emphasis>.
		</para>
		<note>
			We recommend you to first refer to the JPA Outbound Channel Adapter
			section and the JPA Inbound Channel Adapter sections above, as
			most of the common concepts are being explained there.
		</note>
		<para>
			This similarity was the main factor to use the central
			<classname>JpaExecutor</classname> class to unify common functionality
			as much as possible.
		</para>
		<para>
			Common for all JPA Outbound Gateways and simlar to the
			<emphasis>outbound-channel-adapter</emphasis>, we can use
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>Entity classes</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>JPA Query Language (JPQL)</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>Native query</emphasis></para>
			</listitem>
			<listitem>
				<para><emphasis>Named query</emphasis></para>
			</listitem>
		</itemizedlist>
		<para>
			for performing various JPA operations. For configuration examples
			please see <xref linkend="outboundGatewaySamples"/>.
		</para>
		<section id="jpa-outbound-gateway-common-parameters">
			<title>Common Configuration Parameters</title>
			<para>
				JPA Outbound Gateways always have access to the Spring Integration
				Message as input. As such the following parameters are available:
			</para>
			<para><emphasis>parameter-source-factory</emphasis></para>
			<para>
				An instance of
				<interfacename>o.s.i.jpa.support.parametersource.ParameterSourceFactory</interfacename>
				that will be used to get an instance of
				<interfacename>o.s.i.jpa.support.parametersource.ParameterSource</interfacename>.
				The <emphasis>ParameterSource</emphasis> is used to resolve the
				values of the parameters provided in the query. The
				<emphasis>parameter-source-factory</emphasis> attribute is ignored,
				if operations are performed using a JPA entity. If a
				<emphasis>parameter</emphasis> sub-element is used, the factory
				must be of type <classname>ExpressionEvaluatingParameterSourceFactory</classname>,
				located in package <emphasis>o.s.i.jpa.support.parametersource</emphasis>.
				<emphasis>Optional</emphasis>.
			</para>
			<para><emphasis>use-payload-as-parameter-source</emphasis></para>
			<para>
				If set to <emphasis>true</emphasis>, the payload of the Message
				will be used as a source for providing parameters. If set to
				<emphasis>false</emphasis>, the entire Message will be available
				as a source for parameters. If no JPA Parameters are passed in,
				this property will default to <emphasis>true</emphasis>.
				This means that using a default
				<classname>BeanPropertyParameterSourceFactory</classname>, the
				bean properties of the payload will be used as a source for
				parameter values for the to-be-executed JPA query. However, if
				JPA Parameters are passed in, then this property will by default
				evaluate to <emphasis>false</emphasis>. The reason is that JPA
				Parameters allow for SpEL Expressions to be provided and therefore
				it is highly beneficial to have access to the entire Message,
				including the Headers.
			</para>
		</section>
		<section id="jpa-updating-outbound-gateway">
			<title>Updating Outbound Gateway</title>
			<programlisting language="xml"><![CDATA[<int-jpa:updating-outbound-gateway request-channel="" ]]><co id="outGateRequestChannel"/><![CDATA[
    auto-startup="true"
    entity-class=""
    entity-manager=""
    entity-manager-factory=""
    id=""
    jpa-operations=""
    jpa-query=""
    named-query=""
    native-query=""
    order=""
    parameter-source-factory=""
    persist-mode="MERGE"
    reply-channel="" ]]><co id="outGateReplyChannel"/><![CDATA[
    reply-timeout="" ]]><co id="outGateReplyTimeout"/><![CDATA[
    use-payload-as-parameter-source="true">

    <int:poller/>
    <int-jpa:transactional/>

    <int-jpa:parameter name="" type="" value=""/>
    <int-jpa:parameter name="" expression=""/>
</int-jpa:updating-outbound-gateway>]]></programlisting>

			<calloutlist>
				<callout arearefs="outGateRequestChannel">
					<para>
						The channel from which the outbound gateway will receive messages for performing
						the desired operation. This attribute is similar to <emphasis>channel</emphasis> attribute of the outbound-channel-adapter.<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateReplyChannel">
					<para>
						The channel to which the gateway will send the response after performing the required JPA operation.
						If this attribute is not defined, the request message must have a replyChannel header. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateReplyTimeout">
					<para>
						Specifies the time the gateway will wait to send the result to the reply channel.
						Only applies when the reply channel itself might block the send (for example a bounded QueueChannel that is currently full).
						By default the Gateway will wait indefinitely. The value is specified in milliseconds. <emphasis>Optional</emphasis>.
					</para>
				</callout>
			</calloutlist>
		</section>
		<section id="jpa-retrieving-outbound-gateway">
			<title>Retrieving Outbound Gateway</title>
			<programlisting language="xml"><![CDATA[<int-jpa:retrieving-outbound-gateway request-channel=""
    auto-startup="true"
    delete-after-poll="false"
    delete-in-batch="false"
    entity-class=""
    id-expression="" ]]><co id="outGateIdExpression"/><![CDATA[
    entity-manager=""
    entity-manager-factory=""
    expect-single-result="false" ]]><co id="outGateExpectSingleResult"/><![CDATA[
    id=""
    jpa-operations=""
    jpa-query=""
    max-number-of-results="" ]]><co id="outGateMaxNumOfResults"/><![CDATA[
    max-results="" ]]><co id="outGateMaxNumOfResults2"/><![CDATA[
    max-results-expression="" ]]><co id="outGateMaxNumOfResultsExpression"/><![CDATA[
    first-result="" ]]><co id="outGateFirstResult"/><![CDATA[
    first-result-expression="" ]]><co id="outGateFirstResultExpression"/><![CDATA[
    named-query=""
    native-query=""
    order=""
    parameter-source-factory=""
    reply-channel=""
    reply-timeout=""
    use-payload-as-parameter-source="true">
    <int:poller></int:poller>
    <int-jpa:transactional/>

    <int-jpa:parameter name="" type="" value=""/>
    <int-jpa:parameter name="" expression=""/>
</int-jpa:retrieving-outbound-gateway>]]></programlisting>
			<calloutlist>
				<callout arearefs="outGateIdExpression">
					<para>
						(Since <emphasis>Spring Integration 4.0</emphasis>) The SpEL expression to determine the
						<code>primaryKey</code>	value for
						<code>EntityManager.find(Class entityClass, Object primaryKey)</code> method against
						the <code>requestMessage</code> as root object of evaluation context.
						The <code>entityClass</code> argument is determined from <code>entity-class</code> attribute,
						if presented, otherwise from <code>payload</code> class. All other attributed are disallowed
						in case of <code>id-expression</code>. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateExpectSingleResult">
					<para>
						A boolean flag indicating whether the select operation is expected to return a single result or a <classname>List</classname> of results.
						If this flag is set to <code>true</code>, the single entity selected is sent as the payload
						of the message. If multiple entities are returned, an exception is thrown.
						If <code>false</code>, the <classname>List</classname> of entities is being sent as the payload of the message.
						By default the value is <code>false</code>. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateMaxNumOfResults">
					<para>
						<emphasis>Deprecated</emphasis>. Use <code>max-results</code> instead.
						<emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateMaxNumOfResults2">
					<para>
						This non zero, non negative integer value tells the adapter not to select more than given number
						of rows on execution of the select operation. By default, if this attribute is not set,
						all the possible records are selected by given query. This attribute is mutually exclusive with
						<code>max-results-expression</code>. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateMaxNumOfResultsExpression">
					<para>
						An expression, mutually exclusive with <code>max-results</code>, that can
						be used to provide an expression that will be evaluated to find the maximum number of results
						in a result set. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateFirstResult">
					<para>
						This non zero, non negative integer value tells the adapter the first record from which the
						results are to be retrieved This attribute is mutually exclusive to <code>first-result-expression</code>.
						This attribute is introduced since version 3.0. <emphasis>Optional</emphasis>.
					</para>
				</callout>
				<callout arearefs="outGateFirstResultExpression">
					<para>
						This expression is evaluated against the message to find the position of first record in the
						result set to be retrieved This attribute is mutually exclusive to <code>first-result</code>.
						This attribute is introduced since version 3.0. <emphasis>Optional</emphasis>.
					</para>
				</callout>
			</calloutlist>
			<important>
				<para>
					When choosing to delete entities upon retrieval and you have
					retrieved a collection of entities, please be aware that by
					default entities are deleted on a per entity basis. This may
					cause performance issues.
				</para>
				<para>
					Alternatively, you can set attribute <emphasis>deleteInBatch</emphasis>
					to <emphasis>true</emphasis>, which will perform a batch delete.
					However, please be aware of the limitation that in that case
					cascading deletes are not supported.
				</para>
				<para>
					<emphasis>JSR 317: Java Persistence 2.0</emphasis> states
					in chapter Chapter 4.10, Bulk Update and Delete Operations
					that:
				</para>
				<para>
					"A delete operation only applies to entities of the specified
					class and its subclasses. It does not cascade to related
					entities."
				</para>
				<para>
					For more information please see
					<ulink url="http://jcp.org/en/jsr/detail?id=317">JSR 317: Java Persistence 2.0</ulink>
				</para>
			</important>
		</section>
		<section id="outboundGatewaySamples">
			<title>JPA Outbound Gateway Samples</title>
			<para>
				This section contains various examples of the <emphasis>Updating Outbound Gateway</emphasis>
				and <emphasis>Retrieving Outbound Gateway</emphasis>
			</para>
			<para><emphasis>Update using an Entity Class</emphasis></para>
			<para>
				In this example an <emphasis>Updating Outbound Gateway</emphasis>
				is persisted using solely the entity class
				<classname>org.springframework.integration.jpa.test.entity.Student</classname>
				as JPA defining parameter.
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:updating-outbound-gateway request-channel="entityRequestChannel" ]]><co id="gatewayEntityReqChannel"/><![CDATA[
    reply-channel="entityResponseChannel" ]]><co id="gatewayEntityRepChannel"/><![CDATA[
    entity-class="org.springframework.integration.jpa.test.entity.Student"
    entity-manager="em"/>]]></programlisting>
			<calloutlist>
				<callout arearefs="gatewayEntityReqChannel">
					<para>
						This is the request channel for the outbound gateway,
						this is similar to the <emphasis>channel</emphasis>
						attribute of the <emphasis>outbound-channel-adapter</emphasis>
					</para>
				</callout>
				<callout arearefs="gatewayEntityRepChannel">
					<para>
						This is where a gateway differs from an outbound adapter,
						this is the channel over which the reply of the performed
						JPA operation is received. If,however, you are not
						interested in the reply received and just want to perform
						the operation, then using a JPA <emphasis>outbound-channel-adapter</emphasis>
						is the appropriate choice. In above case, where we are
						using entity class, the reply will be the entity object
						that was created/merged as a result of the JPA operation.
					</para>
				</callout>
			</calloutlist>
			<para><emphasis>Update using JPQL</emphasis></para>
			<para>
				In this example, we will see how we can update an entity using
				the Java Persistence Query Language (JPQL). For this we use an
				<emphasis>Updating Outbound Gateway</emphasis>.
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:updating-outbound-gateway request-channel="jpaqlRequestChannel"
  reply-channel="jpaqlResponseChannel"
  jpa-query="update Student s set s.lastName = :lastName where s.rollNumber = :rollNumber" ]]><co id="jpaQlGatewayQuery"/><![CDATA[
  entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
</int-jpa:updating-outbound-gateway>]]></programlisting>
			<calloutlist>
				<callout arearefs="jpaQlGatewayQuery">
					<para>
						The JPQL query that will be executed by the gateway. Since
						an <emphasis>Updating Outbound Gateway</emphasis> is used,
						only <emphasis>update</emphasis> and <emphasis>delete</emphasis>
						JPQL queries would be sensible choices.
					</para>
				</callout>
			</calloutlist>
			<para>
				When sending a message with a String payload and containing a header <emphasis>rollNumber</emphasis>
				with a <emphasis>long</emphasis> value, the last name of the student with the provided roll number
				is updated to the value provided in the message payload. When using an
				<emphasis>UPDATING</emphasis> gateway, the return value is <emphasis>always</emphasis> an integer
				value which denotes the number of records affected by execution of the JPA QL.
			</para>
			<para><emphasis>Retrieving an Entity using JPQL</emphasis></para>
			<para>
				The following examples uses a <emphasis>Retrieving Outbound Gateway</emphasis>
				together with JPQL to retrieve (select) one or more entities from
				the database.
			</para>

			<programlisting language="xml"><![CDATA[<int-jpa:retrieving-outbound-gateway request-channel="retrievingGatewayReqChannel"
    reply-channel="retrievingGatewayReplyChannel"
    jpa-query="select s from Student s where s.firstName = :firstName and s.lastName = :lastName"
    entity-manager="em">
    <int-jpa:parameter name="firstName" expression="payload"/>
    <int-jpa:parameter name="lastName" expression="headers['lastName']"/>
</int-jpa:outbound-gateway>]]></programlisting>

			<para><emphasis>Retrieving an Entity using id-expression</emphasis></para>
			<para>
				The following examples uses a <emphasis>Retrieving Outbound Gateway</emphasis>
				together with <code>id-expression</code> to retrieve (find) one and only one entity from
				the database. The <code>primaryKey</code> is the result of <code>id-expression</code>
				evaluation. The <code>entityClass</code> is a class of Message <code>payload</code>.
			</para>

			<programlisting language="xml"><![CDATA[<int-jpa:retrieving-outbound-gateway
	request-channel="retrievingGatewayReqChannel"
    reply-channel="retrievingGatewayReplyChannel"
    id-expression="payload.id"
    entity-manager="em"/>]]></programlisting>

			<para><emphasis>Update using a Named Query</emphasis></para>
			<para>
				Using a Named Query is basically the same as using a JPQL query
				directly. The difference is that the <emphasis>named-query</emphasis>
				attribute is used instead, as seen in the xml snippet below.
			</para>
			<programlisting language="xml"><![CDATA[<int-jpa:updating-outbound-gateway request-channel="namedQueryRequestChannel"
    reply-channel="namedQueryResponseChannel"
    named-query="updateStudentByRollNumber"
    entity-manager="em">
    <int-jpa:parameter name="lastName" expression="payload"/>
    <int-jpa:parameter name="rollNumber" expression="headers['rollNumber']"/>
</int-jpa:outbound-gateway>]]></programlisting>
			<note>
				<para>
					You can find a complete Sample application for using Spring
					Integration's JPA adapter at:
				</para>
				<para><ulink url="https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jpa">https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jpa</ulink></para>
			</note>
		</section>
	</section>
</chapter>
